## 行为型设计模式

在软件工程中， 行为型模式为设计模式的一种类型，用来识别对象之间的常用交流模式并加以实现. 

行为型是对在不同对象之间划分责任和算法的抽象化. 不仅仅关注类和对象的结构, 而且重点关注它们之间相互作用. 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互.


### [责任链模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/ChainOfResponsibility)

概念: 建立一个对象链来按指定顺序处理调用。如果其中一个对象无法处理命令，它会委托这个调用给它的下一个对象来进行处理，以此类推。

角色:
- Handler（抽象处理者）： 定义一个处理请求的接口，提供对后续处理者的引用
- ConcreteHandler（具体处理者）： 抽象处理者的子类，处理用户请求，可选将请求处理掉还是传给下家；在具体处理者中可以访问链中下一个对象，以便请求的转发。

优点:
- 松散耦合
- 随时地增加或修改处理一个请求的结构, 增加给对象指派职责的灵活性

缺点:
- 如果请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理
- 较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。

### [命令模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/Command)

概念: 允许你在对象中封装行为。该模式背后的主要思想是：提供将客户与接收者解耦的方法。 实际上接收者中间封装命令类来去调用依赖的类, 而非直接去调用依赖的类. 

角色:
- Command(抽象命令类)： 声明了用于执行请求的的execute()等方法
- ConcreteCommand（具体命令类）： 抽象命令类的子类，对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方 法时，将调用接收者对象的相关操作(Action)。
- Invoker(调用者)： 调用命令对象执行请求，相关的方法叫做行动方法。
- Receiver(接收者)： 负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。

优点:
- 命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开
- 命令模式使新的命令很容易地被加入到系统里
- 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易

缺点:
- 使用命令模式，不论命令简单还是复杂，都需要写一个命令类来封装，滥用命令模式会导致系统出现过多的具体命令类；

### [迭代器模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/Iterator)

概念: 访问一个容器对象中各个元素，而又不暴露该对象的内部细节. 当你需要访问一个聚集对象, 而且不管这些对象是什么都需要遍历的时候 为遍历不同的聚集对象提供如开始,下一个, 是否结束,当前哪一项等统一接口

角色:
- 抽象容器：一般是一个接口，提供一个iterator()方法
- 具体容器：就是抽象容器的具体实现类
- 抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext() ），移出当前对象的方法remove(),
- 迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。

优点:
- 用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现

缺点:
- 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
- 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展

### [中介者模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/Mediator)

概念: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它 们之间的交互

角色:
- Mediator（抽象中介者）： 定义了同事对象到中介者对象之间的接口
- ConcreteMediator（具体中介者）： 实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。
- Colleague（抽象同事类）： 它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。
- ConcreteColleague（具体同事类）： 抽象同事类的子类；每个同事对象在与其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。


优点:
- 减少子类的生成   Mediator将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成Mediator的子类即可。
- 它将各Colleague解耦  Mediator有利于各Colleague类间的松耦合。可以独立的改变和复用各Colleague类和Mediator类。

缺点:
- 具体中介者会变复杂, 难以维护


### [备忘录模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/Memento)

概念: 关于用某种方式获取或保存对象当前状态的模式，从而使对象能在稍后顺利恢复。

角色: 
- Memento(备忘录角色)： 负责存储原发器对象的内部状态，但是具体需要存储哪些数据是由原发器对象来决定的，在需要的时候提供原发器需要的内部状态。
- Originator(发起人角色)： 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。
- Caretaker(备忘录负责人角色)： 对备忘录对象进行管理，但是不能对备忘录对象的内容进行操作或检查

优点:
- 使用备忘录模式，可以避免暴露一些只应由源发器管理却又必须存储在源发器之外的信息，而且能够在对象需要时恢复到先前的状态
缺点:
- 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存
- 由于备份的信息是由发起人自己提供的，所以管理者无法预知备份的信息的大小.


### [观察者模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/Observer)

概念: 在对象间定义了一种依赖关系，从而当某个对象的状态改变后，它的所有依赖对象都将得到通知

角色:
- 抽象主题(Subject)角色： 将观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供接口，可以增加和删除观察者对象。抽象主题角色又叫做抽象被观察者 (Observable)角色。
- 具体主题(ConcreteSubject)角色： 将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。
- 抽象观察者(Observer)角色： 为所有的具体观察者定义一个更新接口，在得到主题的通知时更新自己。
- 具体观察者(ConcreteObserver)角色： 观察者的具体实现对象，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。

优点:
- 观察者与被观察者抽象耦合，容易扩展.
- 建立了一套触发机制.

缺点:
- 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间

### [策略模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/Strategy)

概念: 定义了算法家族, 分别封装起来, 让它们之间可以互相切换, 此模式让算法的变化, 不会影响到使用算法的用户.

角色:
- 环境(Context)角色： 持有一个Strategy的引用。
- 抽象策略(Strategy)角色： 这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
- 具体策略(ConcreteStrategy)角色： 包装了相关的算法或行为。

优点:
- 提供了一种替代继承的方法，而且既保持了继承的优点(代码重用)还比继承更灵活(算法独立，可以任意扩展)。
- 避免程序中使用多重条件转移语句，使系统更灵活，并易于扩展。

缺点:
- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。
- 具体策略封装一个类, 假如具体策略过多, 那么对象也相应过多.

### [状态模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/State)

概念: 可以基于一个对象的同种事务而封装出不同的行为。它提供一种简洁的方式使得对象在运行时可以改变自身行为，而不必借助单一庞大的条件判断语句。

角色:
- Context: 环境类
- State: 抽象状态类
- ConcreteState: 具体状态类

优点:
- 封装了转换规则。 
- 枚举可能的状态，在枚举状态之前需要确定状态种类。 
- 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。

缺点:
- 状态模式的使用必然会增加系统类和对象的个数。
- 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。

### [模板方法模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/TemplateMethod)

概念: 定义了某特定算法如何执行的框架，但执行步骤的具体实现则推迟到子类中去完成。

角色:
- 抽象模板(AbstractClass)角色: 定义一个或多个抽象方法让子类实现。这些抽象方法叫做基本操作，它们是顶级逻辑的组成部分。
- 具体模板(ConcreteClass)角色：实现父类的一个或多个抽象方法，作为顶层逻辑的组成而存在

优点:
- 封装不变部分，扩展可变部分。 
- 提取公共代码，便于维护。 
- 行为由父类控制，子类实现。

缺点:
- 如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象

### [访问者模式](https://github.com/uuk020/DesignPatterns/tree/master/Behavioral/Visitor)

概念: 一个作用于某对象结构中各元素的操作。它可以在不修改各元素类的前提下定义作用于这些元素的新操作，即动态的增加具体访问者角色。

角色:
- 抽象访问者角色(Visitor)：为该对象结构(ObjectStructure)中的每一个具体元素提供一个访问操作接口。该操作接口的名字和参数标识了 要访问的具体元素角色。这样访问者就可以通过该元素角色的特定接口直接访问它。
- 具体访问者角色(ConcreteVisitor):实现抽象访问者角色接口中针对各个具体元素角色声明的操作。
- 抽象节点（Element）角色:该接口定义一个accept操作接受具体的访问者。
- 具体节点（Element）角色:实现抽象节点角色中的accept操作。
- 对象结构角色(ObjectStructure)：这是使用访问者模式必备的角色。它要具备以下特征：能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个复合（组合模式）或是一个集合，如一个列表或一个无序集合

优点:
- 符合单一职责原则。 
- 优秀的扩展性。 
- 灵活性。

缺点:
- 如果增加新的元素节点，则会导致包括访问者接口及其子类的改变，这就会违反了面向对象中的开闭原则
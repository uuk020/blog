# 自动执行

每次CLK信号上升沿到来之前，都需要通过2位输入设备生成`RAM`需要的地址信号，而每次生成的地址信号都比上一次生成的大1！对于懒癌患者的我们来说，手动输入地址信号仍然是一件很费力的活，而且也不能保证输不错，所以我们引入一个加法器来继续解放一下双手

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled.png)

我们引入了一个`2位加法器`，并且保证`Cin`始终为逻辑0。加法器的一个输入恒为1，另一个输入是寄存器的输出，也就是说加法器完成的功能就是将寄存器的输出加1。而加法器的输出又作为寄存器的输入，每当CLK信号上升沿到来的时候都把加和结果存储在该寄存器中

初始情况下我们只需要将寄存器清零，然后每次CLK信号上升沿到来后，寄存器的输出都会自动加1～也就是说上图中Y的值将会是0、1、2、3…

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%201.png)

如图所示，在添加了这个“智能”生成地址信号的设备之后，我们的双手又得到了一次解放。不过此时电路图中出现了两个寄存器，为了区分一下，我们把图左下方的那个用于生成地址信号的寄存器称之为`程序计数器`（英文名：Program Counter，简称PC），把图上方之前用于存放累加过程中间结果的那个寄存器称之为`累加器`（英文名：Accumulator，简称ACC）

值得注意的是，`程序计数器`和`累加器`共享同样的CLK信号和同样的RST_N信号

之后就可以按照下边的步骤完成累加4个加数的目标

- 将RST_N设置为逻辑0后再调整为逻辑1
此时`程序计数器`输出的地址信号为`00`，RAM的输出Dout 就是第一个加数，也就是74，累加器的输出为0，ALU的输出就是74+0=74
- 再将CLK信号从逻辑0调整到逻辑1后再调整为逻辑0
此时`程序计数器`输出的地址信号为`01`，RAM的输出Dout 就是第二个加数，也就是29，累加器的输出就是上一步骤中ALU的输出，也就是74，现在ALU的输出就是29+74=103
- 再将CLK信号从逻辑0调整到逻辑1后再调整为逻辑0
此时`程序计数器`输出的地址信号为`10`，RAM的输出Dout 就是第三个加数，也就是32，累加器的输出就是上一步骤中ALU的输出，也就是103，现在ALU的输出就是32+103=135
- 再将CLK信号从逻辑0调整到逻辑1后再调整为逻辑0
    
    此时`程序计数器`输出的地址信号为`11`，RAM的输出Dout 就是第四个加数，也就是20，累加器的输出就是上一步骤中ALU的输出，也就是135，现在ALU的输出就是20+135=155
    

这个过程中需要我们人动手干的就是最初通过设置RST_N来对各个寄存器做清零操作，然后只需要反复调整CLK信号就好了

### **振荡器**

我们现在可以通过1位输入设备手动地将CLK时钟信号从逻辑0调整为逻辑1，之后再将其从逻辑1调整为逻辑0，假设该信号电压波形图是这样的

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%202.png)

从图中可以看到，该信号维持在逻辑0或者逻辑1的时间长短并不相同，如果我们手拿秒表，然后每5秒（也就是让`t₁=t₂=t₃=...=5s`）按动一下1位输入设备的按钮，这样该信号随时间变化的示意图就长这样

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%203.png)

如图所示，CLK信号发生了有规律的变化，具体就是在`t₃～t₄`时间段内该信号的变化方式和`t₁～t₂`时间段内相同，`t₅～t₆`时间段内该信号的变化方式和`t₃～t₄`时间段内相同，我们可以继续推导，该信号在`t₇～t₈`时间段内的变化方式也将和`t₅～t₆`时间段内相同，这样我们就说该信号发生了**周期性变化**。

我们可以把两个相邻的上升沿之间的时间间隔或者两个相邻的下降沿之间的时间间隔称之为该信号变化的一个周期（用大写的`T`表示），该信号的在某一个周期的变化方式和上一个周期的变化方式是相同的，如图所示

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%204.png)

我们每隔5秒调整一次CLK信号，每个周期内需要调整两次，所以一个周期的时间就是10s。那么一秒钟就相当于包含`1/10`，也就是`0.1`个周期，我们把周期的倒数也称为频率，单位为`赫兹`（英文缩写为：Hz），也就是说CLK信号变化的频率为`0.1Hz`

**频率**是一个代表信号在**单位时间内周期性变化快慢**的一个单位，频率越高，意味着信号周期性变化发生的越快，频率越低，意味着信号周期性变化发生的越慢

不停拨动的手指可以让CLK信号发生从逻辑0到逻辑1，再从逻辑1到逻辑0这样的周期性变化，人类非常懒，懒到连按动生成CLK信号的按钮都不想做，所以需要寻找一个可以自动生成CLK信号的设备～ 而反相器正好可以完成将逻辑0变为逻辑1、将逻辑1变为逻辑0的功能，我们看看把反相器的输出连接到它的输入会发生什么神奇的事情：

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%205.png)

使用电路符号其实不是很直观，我们采用反相器的继电器实现来观察一下上述电路

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%206.png)

如图所示，现在A点的信号为逻辑0，经过反相器后得到Y点的信号为逻辑1，而A点和Y点又是通过导线连接，所以A点的信号马上也会变成逻辑１

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%207.png)

在A点的信号变为逻辑1后，经过反相器后，Y点的信号又变成了逻辑０，A点和Y点是通过导线连接的，所以A点的信号又跟着变为了逻辑0。所以Y点信号的变化过程就是

```bash
逻辑0 -> 逻辑1 -> 逻辑0 -> 逻辑1 -> ···
```

循环往复，无休无止，直到电池没电。我们把这种产生周期性变化信号的设备成为`振荡器`。图中的电路绕成了一个环，所以也可以被称作`环形振荡器`

这个环形振荡器特点是结构很简单，但是有一个致命的弊端：它的输出信号频率不能调节。比方说对于上图中使用继电器构成的反相器来说，在电池没电之前，Y点的信号就是一个周期性变化的信号，变化频率取决于继电器通电时将铁片吸下所需的时间以及继电器断电时铁片在弹簧的作用下回归原位的时间长短。

后来科学家们利用石英晶体的压电效应来产生频率稳定并且可调节的周期性变化的信号

现在赶紧使用抽象大法，把这个振荡器封装起来：

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%208.png)

下边就可以使用振荡器来替代手工生成CLK信号的1位输入设备了：

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%209.png)

假设振荡器产生的电压波形图是这样的：

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%2010.png)

在初始时，我们先将复位信号RST_N设置为逻辑0，这样程序计数器和累加器的输出就都清零了。之后在某个时刻，比方说t₀时刻将RST_N设置为逻辑1，之后上述设备就可以自动运行了。为方便分析，我们规定

- 把从t₀时刻到下一个CLK信号上升沿到来的时刻的时间间隔称为第0周期
- 把从下一个CLK信号上升沿到来的时刻到下下个CLK信号上升沿到来的时刻的时间间隔称为第1周期
- 把从下下个CLK信号上升沿到来的时刻到下下下个CLK信号上升沿到来的时刻的时间间隔称为第2周期
- …

以此类推，还有第3周期、第4周期等等。其中，每个时钟周期只包含前一个上升沿，不包含后一个上升沿。如下图所示：

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%2011.png)

对照着电路图，我们可以分析出在不同阶段，程序计数器（简称PC）、RAM、累加器（简称ACC）、ALU的输出都是什么：

| 阶段 | PC输出（地址信号） | RAM输出 | ACC输出 | ALU输出 |
| --- | --- | --- | --- | --- |
| 0 | 0 | 74 | 0 | 74 |
| 1 | 1 | 29 | 74 | 103 |
| 2 | 2 | 32 | 103 | 135 |
| 3 | 3 | 20 | 135 | 155 |

很显然在第3周期的时候，ALU的输出就是我们想要的结果。

不过如果各位稍微思考一下就会发现一个天大的问题：这个电路停不下来！在第3周期结束、第4周期开始时，又一个CLK信号上升沿到来，程序计数器会继续自增。

本例中我们采用的是2位加法器，当程序计数器的值到达3（也就是`11₂`）时，再加1的结果就是4（也就是`100₂`）。而使用2个二进制位是无法表示`100₂`的，所以会产生溢出现象，导致程序计数器会重新从0（也就是`00₂`）开始计数。

随着更多CLK信号上升沿的到来，RAM中的加数会继续累加，ALU的输出不断增大（当然增大到一定程度也会发生溢出）。

这显然不是我们想要的结果，在RAM中的4个加数累加完毕后，我们就想让电路停止运行，继而从8位输出设备中读出结果。其实做到这一点也不难，只要在时钟信号进入第3周期后，让程序计数器和累加器接受到的CLK信号保持不变就好了

也就是让这些寄存器接收不到CLK信号的上升沿），这样所有寄存器输出的值保持不变，看起来相当于电路停止了运行

我们引入一个HALT信号即可解决问题

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%2012.png)

我们在电路图中新增了一个两输入与门，该与门的一个输入信号为振荡器产生的CLK信号，另一个输入信号我们命名为HALT的信号（英文HALT翻译成中文就是“停止”的意思）。这样：

- 当HALT=1时，该与门的输出信号与CLK信号一致，也就是此时与不引入HALT信号的效果是一样的
- 当HALT=0时，该与门的输出信号将保持为逻辑0不变，也就是说在HALT=0时，所有的存储设备接收到的时钟信号都为逻辑0，此时它们均不允许写入数据，相当于整个电路停止了下来

我们在进入第3周期后就可以将HALT信号设置为逻辑0。可是问题是现在CLK信号并不是我们手动生成的，而是通过振荡器自动生成的，我们怎么知道现在已经进入第3周期了呢？

这其实也好办，看程序计数器的输出就好了啊。程序计数器的输出是几，就意味着我们现在进入了第几周期。那我们就可以在初始时让HALT=1，直到程序计数器的输出为3（也就是二进制的11）时，让HALT=0即可

这时就需要引入一个`比较器`来完成这个功能, 通过两输入异或门来实现

| A(输入) | B(输入) | Y(输出) |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

那我们就可以根据异或门的输出信号来判断两个输入信号是否相同：

- 如果异或门的输出信号为逻辑0，那么两个输入信号是相同的
- 如果异或门的输出信号为逻辑1，那么两个输入信号是不相同的

不过人类的一般认知是逻辑0代表否定，逻辑1代表肯定，所以如果可以设计出满足下边功能的设备就更符合人类认知了

- 如果该设备的输出信号为逻辑1，那么两个输入信号是相同的。
- 如果该设备的输出信号为逻辑0，那么两个输入信号是不相同的

实现这个需求超简单的，直接在异或门后边添加一个反相器即可

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%2013.png)

其实这个设备有一个专门的名称：`同或门`（XNOR），并且有专门的电路符号

使用同或门可以轻松比较两个1位二进制数是否相等，如果我们想比较两个n位二进制数的话，只需要使用n个同或门来分别比较这两个数的每一个二进制位。如果这两个n位二进制数相等的话，那么n个同或门的输出信号均为逻辑1，如果不相等的话，那么有的同或门的输出信号就可能为逻辑0

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%2014.png)

上图中的设备就是一个`比较器`，我们可以通过它的输出信号Y，来判断两个输入是否相等

只要将程序计数器的输出和一个固定的值3通过`比较器`比较，如果这两个值不相同，则将HALT信号置为逻辑1，否则置为逻辑0。我们可以这样修改累加电路图

![Untitled](%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%2091f298edae944ba194d442d698286a8b/Untitled%2015.png)

只要在初始的情况下将程序计数器和累加器的输出都清零，然后电路在振荡器产生的CLK信号的推动下自动运行，直到程序计数器输出的值为3（也就是`11₂`）时，比较器得到输出信号为逻辑1，再经过反相器后得到的HALT信号为逻辑0，此时电路中的各个寄存器接收到的CLK信号均为逻辑0，电路停止运行.
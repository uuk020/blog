# 软件程序结构

对于我们刚刚制作的计算机来说，CPU共包含6条地址线，能访问的地址范围是0～63，共64个地址。在引入总线模块之后，我们可以将CPU和各式各样的存储设备都连接到总线模块，这样可以让CPU的地址对应到不同存储设备的不同地址中，我们可以把这个过程称为`地址映射`（即将CPU地址映射到存储器地址）

CPU的每个地址都对应一个占用16个二进制位的存储空间，我们可以把这16个二进制位称作一个存储单元。在CPU眼里，它所看到的存储设备仅仅是64个存储单元，每个存储单元占用16个二进制位罢了，如下图所示：

![Untitled](%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%20df78c36a48694006be53c44d153422a8/Untitled.png)

> 现实生活中常见的存储设备的存储单元一般是8个二进制位，8个二进制位也可以被称作1字节（Byte）。不过我们制作的存储设备的存储单元是2字节的，这主要是为了实现简单起见，要不然各种指令还得区分是处理一个字节的数据还是处理两个字节的数据，还有各种实现细节需要考虑，所以就采用了简单的2字节为1个存储单元的策略
> 

软件程序员的工作就是在上述的存储单元中填入指令和数据，这些指令和数据也可以被统称为`程序`，CPU从存储器中读取指令并执行指令的过程也被称作`运行程序`

理论上把指令和数据放在哪个存储单元中没什么关系，甚至把指令和数据交叉放置也没问题，不过为了方便管理，我们可以将指令写在一个区域，将数据写在另一个区域，这样子CPU地址可以被划分为指令区、数据区以及尚未使用的区域三个部分，如下图所示：

![Untitled](%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%20df78c36a48694006be53c44d153422a8/Untitled%201.png)

当然，指令区、数据区和尚未使用的区域大小并不是固定的，它们占用的地址范围取决于该程序包含的指令条数和数据数量

介绍一下编写软件过程中会用到的三种程序结构

- 顺序结构
- 分支结构
- 循环结构

### 顺序结构

指令按照书写的顺序一条一条向下执行的程序结构称之为`顺序结构`

解决一个问题通常需要将其拆分为若干个步骤，然后一步一步执行就好了。比方说现在有6个同学的考试成绩，我们想计算一下他们的成绩总和，那可以：

- 先将第一位同学的成绩加载到累加器。
- 将第二位同学的成绩与第一位同学的成绩相加后再保存到累加器。
- 将第三位同学的成绩与前两名同学的成绩之和相加后再保存到累加器。
- 将第四位同学的成绩与前三名同学的成绩之和相加后再保存到累加器。
- 将第五位同学的成绩与前四名同学的成绩之和相加后再保存到累加器。
- 将第六位同学的成绩与前五名同学的成绩之和相加后再保存到累加器

顺着这个思路，我们可以编写如下所示的程序：

![Untitled](%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%20df78c36a48694006be53c44d153422a8/Untitled%202.png)

如上图所示，指令是按照地址的顺序依次向下执行，每次新执行的指令都会比上一次执行的指令的地址大1，这就是所谓的`顺序结构`，这种结构是我们编写程序时最常用到的结构

在我们编写的这个程序中：

- `指令区`占用的地址范围是0～7，共包含8条指令
- `数据区`占用的地址范围是8～14，共包含条个数据，其中前6条数据，也就是地址为8～13的存储单元是用于保存同学们的成绩，最后一条数据，也就是地址为14的存储单元是用于保存计算结果的
- 剩下的存储单元作为了`尚未使用的区域`

### **分支结构**

人生不会一帆风顺的走下去，会时不时的面临十字路口供我们选择。写程序也一样，我们经常需要根据条件的变化而去执行不同的指令

比方说我们把六位同学的成绩存储到了地址为14～19的存储单元中，现在我们想：

- 如果地址为13的存储单元中存储的数字不是`1`，那么就计算前3名同学的成绩总和
    
    计算前3名同学成绩总和的程序如下所示：
    
    ```
    load_m 14
    add_m 15
    add_m 16
    store 20
    halt
    ```
    
- 如果地址为13的存储单元中存储的数字是`1`，那么就计算后3名同学的成绩总和
    
    计算后3名同学成绩总和的程序如下所示：
    
    ```
    load_m 17
    add_m 18
    add_m 19
    store 20
    halt
    ```
    

这就是一个根据某个条件的成立与否，来让程序去执行不同指令的场景，这种根据某个条件是否成立来决定指令执行的顺序的程序结构称作`分支结构`。

分支结构的实现依赖于我们发明的跳转指令je、jmp（jmp是无条件跳转指令，无需判断条件即可跳转）

为了解决上例中的问题，我们可以这样编写程序：

![Untitled](%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%20df78c36a48694006be53c44d153422a8/Untitled%203.png)

其中地址为3～7的存储单元中的指令用于计算前3位同学的成绩总和，地址为8～12的存储单元中的指令用于计算后3位同学的成绩总和

现在看看其他指令都完成了什么功能（为方便大家理解，我们在指令前边加上了该指令所在存储单元的地址，并以分号分隔，另外，在指令后边添加了分号，分号之后的内容是注释，即解释这条指令做了什么事情）

```
0: load_m 13    # 将地址为13的存储单元中的数据加载到累加器
1: sub_i 1      # 将累加器的值减1
2: je 21        # 如果上一条指令的结果为0，那么就跳转到地址为21的存储单元中存储的地址处的指令执行，否则按地址顺序执行下一条指令
```

这3条指令的作用就是判断地址为13的存储单元中的数据是不是1，如果不是1的话，就按照地址顺序执行下一条指令（也就是地址为3的指令，即计算前3位同学的成绩总和），否则跳转到地址为21的存储单元中存储的地址处的指令执行（地址为21的存储单元中存储的数据是8，即跳转到地址为8处的指令执行，即计算后3位同学的成绩总和）

> 这里有的同学可能比较奇怪，很明显如果地址为13的存储单元中存储的数据是1，那就要跳转到地址为8处的指令执行，为什么不直接写个`je 8`
作为跳转指令呢？别忘了，我们设计的CPU的je指令的操作数只支持地址（jmp指令也一样），并不支持立即数作为je指令的操作数。也就是在执行je指令时，必须先将它的操作数作为地址，读取出该地址所在存储单元的数据后，然后再将读出的数据作为真正的跳转地址
> 

这时很多小伙伴肯定有这样的疑惑：你在写程序的时候明明都知道地址为13处的存储单元存储的数据是1了，为啥还要判断一下它是不是1呢，这不是脱了裤子放屁吗？

必须澄清一下：是的，在目前的场景下的确是脱了裤子放屁！这只不过是我为了引入`分支结构`这个概念而强行做的一个设定。其实我们在很多编程场景下是不知道某个存储单元的值是什么的，这一点在现在大家可能没什么体会，在学了`函数`概念之后才能深刻理解

### 循环结构

如果我们想编写计算从1到10这10个数字的总和的程序，也就是下边这个式子：

```
1 + 2 + 3 + ··· + 10
```

可以这样写：

```makefile
0: load_i 1
1: add_i 2
2: add_i 3
3: add_i 4
4: add_i 5
5: add_i 6
6: add_i 7
7: add_i 8
8: add_i 9
9: add_i 10
```

那如果想计算从1到100这100个数字的总和的程序呢？要写100条指令吗（假设CPU支持这么多的地址）？

其实解决这个问题只需要引入2个存储单元：

- 一个存储单元用于存储当前加到了第几个数，我们给这个存储单元起个名，称作`i`，`i`的初始值为1（意思是从1开始累加）
- 另一个存储单元用于存储当前的加和结果，我们给这个存储单元起个名，称作`sum`，`sum`的初始值为0（意思是最初累加的和为0）

那么我们可以不断的重复下边两个步骤，直到i的值为100为止：

- 步骤一：让 sum 等于 sum 的值加上 i 的值
- 步骤二：让 i 等于 i+1

这样的话，指令数量就会大大减少，让我们写一下这个程序：

![Untitled](%E8%BD%AF%E4%BB%B6%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%20df78c36a48694006be53c44d153422a8/Untitled%204.png)

其中地址为10的存储单元就是`i`，地址为11的存储单元就是`sum`

接下来详细分析一下这个程序是在干啥，先看一下前三条指令：

```makefile
0: load_m 11    # 将sum加载到累加器中
1: add_m 10     # 计算sum+i的值
2: store_m 11   # 将上一步计算得到的sum+i的值再写回到sum中
```

然后看一下地址为3 ~ 5的指令：

```makefile
3: load_m 10    # 将i加载到累加器中
4: add_i 1      # 计算i+1的值
5: store_m 10   # 将上一步计算得到的i+1的值再写回到i中
```

再看地址为`6`的指令

```makefile
6: sub_i 101   # 用i减去101
7: je 13        # 如果i的值等于101，那么就跳转到地址13对应的存储单元中存储的地址，也就是9。地址为9的指令是halt，表示程序结束，否则执行下一条指令，也就是地址为8的指令
8: jmp 12       # 无条件跳转到地址12对应的存储单元中存储的地址，也就是0。
```

地址为6～8的这三条指令的作用是

- 如果当前i已经达到了101，表示目前已经累加了1到100这100个数，可以让程序停下来了，所以接下来应该执行halt指令
- 如果当前i尚未达到101，表示还需要继续进行累加，所以跳转到地址为0的执行继续执行累加操作

### 函数

目前设计的指令中只支持下边两种类型的操作数：

- 立即数，也就是在指令中我们就知道要操作的数据是什么，比方说`add_i 10`，表示将10与累加器中的数据相加。通过立即数来定位指令实际需要操作的数据的方式也被称作`立即寻址`
- 地址，比方说`add_m 10`，表示先将地址为10的存储单元中存储的数据读出后，再使用读出后的数据参与运算。这种在指令中直接指定实际需要操作的数据的地址的方式也被称作`直接寻址`
，即直接在指令中指出实际需要操作数据的地址。需要注意的是，在`直接寻址`中，实际需要操作的数据的地址是以常数的形式出现在指令中的

这两种寻址方式非常局限，导致我们能做的操作十分有限。仅支持这两种寻址方式的话是无法实现函数功能的，还得引入所谓的`间接寻址`（即在指令中并不以常数的形式直接写明实际需要操作数据的地址，而是将地址存到别的地方，比方说寄存器或者别的存储单元中）才能实现函数
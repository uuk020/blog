# 中断和异常

看一下下边两个问题：

- 狗哥和猫爷分别写了一个程序，他们的程序都想在CPU上运行。狗哥的程序大概需要3个小时才能运行完，猫爷的程序大概要5个小时才能运行完。此时我们能做的就是先等狗哥的程序运行完，然后再执行猫爷的程序
很显然这个过程对猫爷很不公平，凭什么自己的程序要等别人的程序运行完了才能运行呢？如果狗哥写的是一个游戏程序，那么用户不主动关闭程序的话就永不停止，那猫爷的程序岂不是永远都不能运行了？
- 对于CPU来说，I/O设备的速度是很慢的，CPU想访问I/O设备时，只能依靠`轮询`的方式查看I/O设备是否准备好，在轮询时CPU是不能去做别的事情的，这是对CPU的一种浪费

之所以有上述的两个问题，是因为在我们目前的设计中，CPU拥有牢牢的主动权，即CPU主动的从主存中取指令和数据并执行指令，CPU主动的从输入设备中读数据也主动的将数据写入到输出设备，在整个执行程序的过程中，外部设备并不会打断CPU的工作。如果外部设备能够打断CPU的工作，那上边两个问题可以很容易的解决：

- 我们可以在CPU外部做一个计时器，可以规定每当过多少个时钟周期就打断CPU一下，CPU在收到外部的打断信号后，就先不执行当前正在执行的程序，转而去执行另一个程序去。这样的话，狗哥和猫爷的程序就可以轮着被CPU执行
- 当I/O设备准备好数据后，主动通知CPU，CPU可以先暂停下手头的事情去处理外部设备的通知，等处理完了再回去做原先的事情

这个外部设备打断CPU的正常执行流程的机制被称作`中断机制`，外部设备打断CPU的通知被称作`中断请求`，产生`中断请求`的设备也可以被称作`中断源`

当CPU执行完当前正在的指令后，会检测有没有外部设备给自己发送中断请求，如果有的话，可以跳转到所谓的`中断服务程序`。我们可以自己编写自己的中断服务程序

比方说CPU收到的是计时器中断的话，可以让CPU跳转到猫爷的程序执行；如果收到的是键盘中断的话，可以将按键值存储到某个地方，然后再返回到中断发生之前的下一条指令继续执行原程序

### **软件中断**

在写和I/O设备打交道的程序时候需要注意很多问题，比方说我们想让显示器显式一些字符，我们得考虑写入的字符展示在显示器的哪个位置，还得考虑如果写的字符多了应该让显示器的文字如何翻滚，还有许许多多的细节需要考虑，这是在每一个程序员进行编程时都会遇到的问题。

为了方便广大程序员，我们可以把和硬件打交道的程序都事先写出来，后续的程序员只需要跳转到相应的指令地址去执行就好了。这些事先写好的和硬件打交道的程序也被称作`操作系统`（当然，操作系统还有别的很多功能），我们自己写的程序也被称作`用户程序`

每当用户程序需要使用到操作系统提供的某些功能的话，就需要先跳转到操作系统程序的某个地址处。可是操作系统会不断的升级换代，它的程序也会不断的修改，每个功能的入口地址可能一直都在变，这就意味着每次更新操作系统后，用户程序也需要跟着调整，这是十分不方便的

此时我们可以引入一种软件中断指令，当CPU执行到软件中断指令时，CPU会跳转到相应的中断服务程序。操作系统可能提供若干种不同的功能，每个功能可以被编一个号，比方说0号功能，1号功能等等，我们在使用软件中断指令时，可以将想要使用的操作系统功能编号写在某个寄存器或者存储单元中，甚至可以直接写在指令的操作数中，这样在中断服务程序中就可以知道应该跳转到哪个功能对应的地址处去执行。用户程序采用软件中断的这种形式去使用操作系统提供的功能也被称作`系统调用`

### **异常**

软件程序员编写的程序在执行过程中可能遇到很多意外情况，比方说：

- 我们使用了一个未定义指令。
- 算术操作指令（比方说add、sub）发生溢出
- 在支持除法指令的CPU中除数为0

当然还有很多意外情况，我们就不一一列绝了，这些意外情况统称为`异常`。当异常发生时，CPU应该暂停目前正在执行的程序，转而去执行所谓的`异常服务程序`，如果异常能在`异常服务程序`中修复，则返回原程序继续执行发生异常的那条指令，如果不能修复，那就终止程序就好了

### CPU的异常处理

不论是外部中断、软件中断还是异常，CPU的处理方式都是一样的，我们统称为CPU的异常处理，处理方式大致分为2步

- 在取指前先检测一下有没有发生外部中断、软件中断或者异常，如果发生了，需要跳转到中断服务程序或者异常服务程序去处理
    - 对于外部中断来说，每一个外部中断源都可以有一根中断信号线与CPU相连，我们可以规定当中断信号线为逻辑1时，表示有中断产生。当然，CPU也可以选择处理或者不处理某个外部中断，所以需要引入一个`中断屏蔽寄存器`，如下图所示：
        
        ![Untitled](%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%20ae7c947ee54f4dd3b057050484e195d8/Untitled.png)
        
        上图中共画了IRQ0、IRQ1、IRQ2、IRQ3（IRQ是Interrupt Request的缩写）四个中断请求
        
        相应的，`中断屏蔽寄存器`包含4个二进制位，与中断请求一一对应。 `中断屏蔽寄存器`的值可以通过专用的指令进行设置（我们并未实现这种指令），当CPU不想处理某个中断请求时，可以将中断屏蔽寄存器相应的二进制位设置为逻辑1
        
        上图中还引入了一个用于保存中断信号的寄存器，这是因为CPU在跳转到中断处理程序后，需要知道到底是谁引起了中断
        
        另外还引入了一个保存是否允许中断的寄存器，当该寄存器的值为1是，表示CPU会处理中断请求，否则CPU不会处理中断请求。该寄存器的值也可以通过专用的指令进行设置（我们并未实现这种指令）
        
        上述装置会生成一个OUTER_INT信号，如果OURTER_INT=1表示有外部中断产生，在取指时就需要跳转到中断处理程序去处理
        
    - 对于软件中断来说，我们需要设计专用的中断指令来支持软件中断。我们可以通过修改控制单元，让控制单元可以识别该指令是否是软件中断指令，如下图所示：
        
        ![Untitled](%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%20ae7c947ee54f4dd3b057050484e195d8/Untitled%201.png)
        
        如果INT_INS=1时，表明该指令是软件中断指令，否则不是。在取指时如果INT_INS=1就需要跳转到中断处理程序去处理
        
    - 对于异常来说，有各种各样不同的异常可能发生，我们需要分别设计相应的硬件去处理，这里以使用未定义指令的异常为例来唠叨一下。我们可以通过修改控制单元，让控制单元可以实别某个指令是不是未定义指令，如下图所示：
        
        ![Untitled](%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%20ae7c947ee54f4dd3b057050484e195d8/Untitled%202.png)
        
        如果UNDIFINED_INS=1时，表明该指令是未定义指令，否则不是。在取指时如果UNDIFINED_INS=1就需要跳转到异常处理程序去处理
        
    
    上边的叙述解决了发生中断或异常时要不要跳转的问题，下边应该解决跳转到哪里的问题。外部中断、软件中断和异常发生后跳转到的指令地址可以是不同的，也可以是相同的，这取决于我们的设计。比方说我们想让它们跳转到不同的地址：
    
    - 当发生异常时，也就是当UNDEFINED_INS=1时，让程序跳转到地址为30处执行。
    - 当发生软件中断时，也就是当INT_INS=1时，让程序跳转到地址为40处执行。
    - 当发生外部中断时，也就是当OUTER_INT=1时，让程序跳转到地址为50处执行。
    - 否则按照正常的执行流程执行
    
    那么我们可以这样设计电路：
    
    ![Untitled](%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%20ae7c947ee54f4dd3b057050484e195d8/Untitled%203.png)
    
    如上图所示，new_pc就是CPU下一条要执行的指令地址
    
- 当中断服务程序或者异常服务程序执行完后，需要返回到原程序继续执行
    
    我们需要搞清楚返回到原程序时，返回的地址是个啥
    
    - 对于外部中断来说，CPU只会在当前指令执行完成后，在读取下一条指令前才会判断有没有外部中断发生，那么在中断服务程序执行完成后，需要跳转到原先正常执行流程的下一条指令
    - 对于软件中断来说也一样，需要跳转到原先正常执行流程的下一条指令
    - 对于异常来说，有些异常不可恢复，比如执行到未定义指令，此时应该在异常处理程序中停止程序的执行，有些异常可以恢复，比方说缺页异常，此时执行完异常处理程序后应该跳转到原先正常执行逻辑的原指令继续执行
    
    很显然，不论发生中断还是异常，在跳转到相应的服务程序前都需要保存一下执行完服务程序后需要恢复到的地址
    

中断和异常是CPU的一种非正常执行逻辑，在CPU进行异常处理时，还需要特别注意两个事情：

- 当进入中断服务程序或异常服务程序时需要注意“保护现场”。
    
    所谓的“现场”指的是执行原程序时肯定会读写一些寄存器，在我们制作的CPU中就是累加器和ZF寄存器，在执行中断服务程序或异常服务程序时肯定也会修改这些寄存器，如果放任其不管的话，那么在恢复到源程序时，这些寄存器的值被修改了就会导致原程序的执行错误，所以我们在进入中断服务程序或者异常服务程序时需要将这些寄存器的值保存到主存中。这个任务可以通过设计硬件完成，也可以我们在软件中自己完成，比方说进入中断服务程序或者异常服务程序时先调用store指令保存一下累加器的值
    
- 当从中断服务程序或异常服务程序时需要注意“恢复现场”。
    
    也就是将进入中断服务程序或异常服务程序时保存的那些寄存器的值再恢复出来，这样才能让原程序觉得刚才啥也没发生，就像是时间暂停了一会儿，然后继续开心的往下执行就好了
    

### **指令集体系结构概述**

作为软件程序员的你买了一个CPU，你其实并不需要知道CPU里边到底是怎么设计电路的，只需要参照这个CPU的说明书去编写指令就好了

在CPU的说明书里，会告知软件程序员在编程时可以使用的指令有哪些，这些指令的集合也被称作`指令集`（Instruction Set），还会告知软件程序员可以使用的寄存器有哪些，可以访问的存储单元地址范围是什么，指令的寻址方式有哪些，如何访问I/O设备等等，CPU说明书里的这些内容可以统称为`指令集体系结构`或`指令集架构`（Instruction Set Architecture），简称ISA

A厂家和B厂家制造的电视机的内部构造可能是不同的，但可以提供相同的使用方式，即电视上的按键和遥控器的功能都相同。这样狗哥在会使用A厂家的电视后，就可以毫不费力的操作B厂家的电视。类似的，A厂家和B厂家可以生产内部构造并不相同，但却拥有相同`指令集体系结构`的CPU。这样软件程序员在A厂家生产的CPU上编写的软件程序，可以很容易的就运行在B厂家生产的CPU上。很显然，`指令集体系结构`充当了一个中间人，硬件工程师遵照`指令集体系结构`的说明去设计硬件，软件工程师遵照`指令集体系结构`的说明去编写软件，硬件工程师和软件工程师并不需要直接沟通

`指令集体系结构`是独立于CPU的具体电路实现而抽象出的一个概念，CPU的具体电路实现也被称作`微体系结构`

这些`指令集体系结构`可以被分成两个大类：

- 复杂指令集，英文名：Complex Instruction Set Computer，简称CISC。
- 精简指令集，英文名：Reduced Instruction Set Computer，简称RISC
# 锁存器和寄存器

在我们忽略导线电阻的情况下，一条导线上各点的电压都是相同的。比方说我们使用1位输入设备生成一个电压信号，那么下图中A₀点的电压和Y₀点的电压是相同的，也就是A₀点的信号和Y₀点的信号是相同的

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled.png)

当我们改变A₀点的信号时，Y₀点的信号也会跟着改变，并且始终保持Y₀=A₀

如果我们在A₀点和Y₀点之间加入一个传输门，如下图所示:

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%201.png)

- 当S₀=1时，传输门导通，Y₀=A₀
- 当S₀=0时，传输门截止，Y₀进入高阻态，也就是Y₀点的信号与A₀点的信号毫无关系

如果能在S₀=1时，Y₀=A₀，而在S₀=0时，Y₀保持原信号不变（不受A₀的影响）。这就意味着将电压信号给“锁”起来了，S₀信号就是那个开锁的钥匙

现在本质上只是想从A₀和Y₀中选一个信号作为新的Y₀，这不就是从两个输入信号中选一个作为输出信号的需求

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%202.png)

- S₀=1时，TG1截止，TG2导通，我们把传输门画成开关的形式，那么上图就变成了
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%203.png)
    

           即 S₀ = 1,   Y₀ = A₀

- 当S₀=0时，TG1导通，TG2截止，我们把传输门画成开关的形式，那么上图就变成了
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%204.png)
    
    上图只是简单的将导线的一端盘了一个圈，并没有电源正极或者负极或者外部的信号线与Y₀点相连，此时Y₀点的信号取决于它后续的电路是什么，这个电路自身是无法让Y₀点的电压保持在高电压或者低电压状态的
    

在S₀=1时，Y₀=A₀，但是在S₀=0时，Y₀却不是保持原先的信号不变，而是取决于Y₀点后续的电路是什么。怎么样才能让Y₀保持原先的信号不变呢？其实引入两个反相器即可

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%205.png)

- 当S₀=1时，TG1截止，TG2导通，我们把传输门画成开关的形式
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%206.png)
    
    很显然，A₀点的信号通过两个反相器后与原先的信号肯定是相同的，也就是说当S₀=1时，Y₀=A₀
    
- 当S₀=0时，TG1导通，TG2截止，我们把传输门画成开关的形式
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%207.png)
    
    多了两个反相器和没有这两个反相器有什么区别吗？我们把反相器的晶体管级别的实现画出来就一目了然了（我们特意在图中标出了P₁、P₂、P₃三个点，以便于后续分析）：
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%208.png)
    
    - 当原先Y₀=0时，P₁=0；由于P₁=0，所以P₁点的信号通过第一个反相器后，P₂=1；P₂点的信号通过第二个反相器后，P₃=0，那么新的Y₀信号仍是逻辑0，只不过新的Y₀信号的逻辑0是因为Y₀点与第二个反相器的电源负极相连接得到的
    - 当原先Y₀=1时，P₁=1；由于P₁=1，所以P₁点的信号通过第一个反相器后，P₂=0；P₂点的信号通过第二个反相器后，P₃=1。那么新的Y₀信号仍是逻辑1，只不过新的Y₀信号的逻辑1是因为Y₀点与第二个反相器的电源正极相连接得到的
    
    可以看到，在引入了两个反相器后，当S₀=0时，Y₀保持原先的信号不变，新的Y₀信号是通过第二个反相器的电源正极或者电源负极产生的
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%209.png)
    
    上述设备有将信号“锁住”的能力，而S₀就是控制锁的钥匙。上述设备也被称作`锁存器`
    

### 支持复位的锁存器

肯定会发现计算器上都有一个清零键，也就是之前不论我们在计算器上做了什么运算，输入了什么数字，按下清零键时一切都会从头开始。对于锁存器来说，我们也期望有这么一个清零键，可以在不论输入信号A₀是什么的情况下，输出信号Y₀都变为逻辑0。做到这一点也很容易，引入一个与门即可做到

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2010.png)

- 当RST_N=1时，基于与门“当一个输入信号为逻辑1，输出信号与另一个输入信号相同”的特性，与门的输出信号，也就是Y₀，就与第二个反相器的输出信号相同，也就意味着这种情况与没引入与门和RST_N信号时完成的功能相同
- 当RST_N=0时，基于与门“当一个输入信号为逻辑0，输出信号肯定为逻辑0”的特性，与门的输出信号，也就是Y₀肯定为逻辑0。此时也就达到了对输出信号清零的目的

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2011.png)

其中D代表输入信号（D是Data的缩写）；CLK代表`2-1选择器`
的选择信号，CLK是CLOCK的缩写，该信号也被称作时钟信号（之后我们再讲为什么要将选择信号称为时钟信号）；Q代表输出信号

- 当CLK=1时，输出信号Q和输入信号D是相同的，也就是从功能上来说，此时锁存器相当于一根儿导线，我们可以无视它的存在，把它当作透明的即可，我们也可以说现在该锁存器处于透明状态。为了更直观地表示一下这个锁存器的透明状态，我们在画它的示意图的时候使用绿色背景填充一下

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2012.png)

- 当CLK=0时，输出信号Q保持不变，再改变输入信号D也不会改变输出信号Q，我们就称此时该锁存器处于不透明状态，采用红色背景填充一下处于不透明状态的D锁存器
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2013.png)
    

### 寄存器

一个信号可以随着时间在逻辑0和逻辑1之间变化，我们可以用该信号的电压为纵轴，时间为横轴来画该信号的电压随时间变化的图，这种图称之为`电压波形图`

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2014.png)

高电压对应着逻辑1，低电压对应着逻辑0。该CLK信号在t₁时间内保持为逻辑0，之后调整为逻辑1后又保持了t₂时间，之后调整为逻辑0后又保持了t₃时间，然后接着变化～ 我们把信号从逻辑0变为逻辑1的过程称为上升沿，反之，把信号从逻辑1变为逻辑0的过程称为下降沿

对于锁存器来说，在整个CLK=1的期间它都处于透明状态, 我们现在期望只在CLK信号的上升沿或者下降沿处使锁存器透明, 为了实现这个功能，可以使用两个锁存器来改进

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2015.png)

如图所示，我们在电路中使用了两个锁存器`L1`和`L2`。CLK信号通过一个反相器得到CLK₁信号，而CLK₂信号与CLK信号相同，这也就是说L1和L2接受的时钟信号始终是相反的,输入信号D作为L1的输入信号D₁，L1的输出信号Q₁作为L2的输入信号D₂，L2的输出信号Q₂作为最终的输出信号Q。L1和L2接受相同的复位信号RST_N

当复位信号RST_N=0时，最终的输出信号Q肯定为逻辑0。

当复位信号RST_N=1时，我们分析一下这个电路的工作过程：

- 当CLK=0时，则有CLK₁=1，CLK₂=0。那么L1透明，L1的输出信号Q₁和输入信号D₁相同, L2的输入信号D₂与L1的输出信号Q₁相同，但是此时L2不透明，导致输入信号D₂无法传播到L2的输出信号Q₂，L2的输出信号Q₂保持原先的信号不变
    
    比方说当输入信号D为X（X可以代表逻辑0或者逻辑1），该电路的信号传播示意图如下所示：
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2016.png)
    
- 当CLK=1时，则有CLK₁=0，CLK₂=1。那么L2透明，L1的输出信号Q₁就可以作为L2的输入信号D₂传播到L2的输出信号Q₂，信号传播示意图示意图如下所示
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2017.png)
    
    值得大家注意的重点来了！在CLK=1之后，L1不透明，即使我们再改变输入信号D，也不会改变最终的输出信号Q（也就是L2的输出信号Q₂），比方说我们现在把输入信号D改变为Y（Y可以代表逻辑0或者逻辑1），那么最终的输出信号Q仍为X
    
    就是说当CLK=0时，L1透明，L2不透明，输入信号D可以通过L1而无法通过L2；当CLK=1时，L1不透明，L2透明，原先通过L1的信号可以传播到L2的输出，但是此时重新改变输入信号D却无法通过L1。这样就形成了一个事实：只有在时钟信号CLK从逻辑0变为逻辑1的瞬间，也就是在CLK时钟信号的上升沿处才能将输入信号D传输到最后的输出信号Q上
    
    可以把这个只在时钟信号上升沿处可以将输入信号D传播到最终输出信号Q，其他时间最终输出信号Q保持不变的电路称作`寄存器`（英文名：register）
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2018.png)
    

有时候我们需要让寄存器不受输入信号D和CLK信号的影响，一直保持输出信号不变，也就是说即使CLK信号上升沿到来，也不能将输入信号D传送到输出信号Q。做到这一点也很容易，引入一个`2-1选择器`即可，如下图所示:

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2019.png)

- 当S₀=0时，输出信号Q保持不变。
- 当S₀=1时，寄存器恢复正常行为，也就是当CLK信号上升沿到来时，会将输入信号D传输到输出信号Q

`2-1选择器`的选择信号S₀起到了控制是否可以在CLK上升沿到来时，将输入信号D传递到输出信号Q，我们给这个选择信号重新起个名，叫WE，代表Write Enable

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2020.png)

对于寄存器来说，只要CLK信号不从逻辑0变为逻辑1，那么输出信号Q就保持不变，这个保持不变的过程就意味着把信号`存储`了起来。信号就代表着数据，也就意味着把数据存储起来。一个寄存器可以存储1位二进制数据

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2021.png)

我们将4个寄存器连接起来，并且所有的寄存器都接受相同的CLK信号和RST_N信号。这样的话，在复位信号RST_N=1时，每当CLK信号从逻辑0变为逻辑1时，都可以把4位二进制数存储起来!因为图中的设备能存储4位二进制数据，所以也可以被称之为`4位寄存器`

### 应用寄存器

计算: 

```bash
74 + 29 + 32 + 20
```

![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2022.png)

1. 做的是加法操作，所以我们需要先将上图中ALU的控制信号调节成`00`（也就是十进制的0），然后将CLK信号先设置为逻辑0
2. 将复位信号RST_N设置为逻辑0从而完成8位寄存器的清零操作。然后在`8位输入设备`
上生成第一个加数`01001010₂`（74₁₀）对应的信号
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2023.png)
    
    当复位信号RST_N=0时，寄存器的输出代表的十进制值就是0，与另一个使用8位输入设备手动输入的加数74通过ALU相加之后得到的结果也是74。之后就可以将RST_N信号调整为逻辑1
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2024.png)
    
    由于此时CLK=0，所以尽管寄存器的输入是74，但是输出还是保持为0
    
3. 将CLK信号从逻辑0调整到逻辑1，在8位输入设备上再生成第2个加数`00011101₂`（29₁₀）对应的信号
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2025.png)
    
    将CLK信号从逻辑0调整为逻辑1时，原先寄存器的输入74将传输到输出，与我们手动输入的另一个加数29通过ALU之后得到新的结果103, 然后我们可以将CLK信号再从逻辑1调整为逻辑0，但是这个过程并不会改变寄存器的输入输出状态
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2026.png)
    
4. 将CLK信号从逻辑0调整到逻辑1，在8位输入设备上再生成第3个加数`00100000₂`（32₁₀）对应的信号

    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2027.png)
    
    将CLK信号从逻辑0调整为逻辑1时，原先寄存器的输入103将传输到输出，与我们手动输入的另一个加数32通过ALU之后得到新的结果135, 然后我们可以将CLK信号再从逻辑1调整为逻辑0，但是这个过程并不会改变寄存器的输入输出状态
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2028.png)
    
5. 再将CLK信号从逻辑0调整到逻辑1，在8位输入设备上再生成第4个加数`00010100₂`（20₁₀）对应的信号
    
    ![Untitled](%E9%94%81%E5%AD%98%E5%99%A8%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%208eab284ed90e401cb9a06fd3fb5ed33f/Untitled%2029.png)
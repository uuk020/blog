# 存储器层次结构和I/O设备

指令和数据是放到存储设备中的，然后CPU负责从存储设备中取出指令并执行它们。其中，各式各样的存储设备可以通过相应的控制器连接到总线模块，以完成和CPU的通信

但是，各种存储设备在速度、容量和成本上各有不同，但基本遵循这样的规律：

- 速度越快的存储设备的单个二进制位存储成本越高，容量不会做的太大
- 速度越慢的存储设备的单个二进制位存储成本越低，容量可以做的很大

每一个软件程序员都希望自己能有无限量的存储单元可用，并且这些存储单元的访问时间越低越好, 想法是美好的，但现实是残酷的，现实世界中我们需要搭配不同成本、容量、速度的各种存储设备，以求用最小的成本来实现最好的性能

- 寄存器
    
    寄存器是速度最快的存储设备，但它的成本也最高。目前我们制作的CPU中引入了多个寄存器，诸如程序计数器、指令寄存器、ZF寄存器、累加器等，其中累加器和软件程序员的关系最为密切，因为我们的大部分指令都是在操作累加器：
    
    - load指令将数据从外界的存储设备加载到累加器中
    - 算术/逻辑运算指令针对累加器中保存的数据进行运算，并将结果再保存回累加器中
    - store指令将累加器中的数据写回到外界的存储设备中
    
    总结一句话就是累加器用于临时存储程序运行过程中产生的数据
    
    CPU仅仅只包含1个临时存储程序运行过程中产生的数据的寄存器太少了，简直少的可怜，如果多弄几个像累加器一样的寄存器，那么在编写程序的时候尽量在各个寄存器之间进行运算，尽量的少从外界存储设备加载数据以及将数据写回到外界存储设备中，那么性能必将有很大的提高
    
    事实上，几乎所有现代CPU内部都包含了若干个用于临时存储数据的寄存器，人们把这些寄存器称作`寄存器组`，或者`寄存器文件`（Register File）。
    
    软件程序员在编写程序的时候，可以在指令中显式指定我们要将外界存储设备中的数据加载到`寄存器文件`中的哪个寄存器中，或者在指令中显式指定对`寄存器文件`中的哪两个寄存器进行啥样的算术/逻辑运算，运算结果再写回到哪个寄存器中
    
    这样的话，尽量在`寄存器文件`中进行运算，减少外界存储设备的访问，可提高性能。但是`寄存器文件`中包含的寄存器数量不会太多，现代CPU一般会放置十几或者几十个这样的寄存器供我们软件程序员使用
    
- 主存
    
    主存储器（Main Memory），可简称为主存。当CPU开始运行时，它将从主存中获取指令和数据，一般以DRAM作为主存
    
    之前一直使用简易的输入设备来将指令和数据人工手动输入到RAM中，每次都得从头开始输入程序，效率太低，且极易出错。后来人们发明了一种叫`穿孔纸带`的东西，差不多长这样
    
    ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%92%8CI%20O%E8%AE%BE%E5%A4%87%2089767b595e79430bbf71546fe3ec5d03/Untitled.png)
    
    上图所示的纸带中一行最多可以打9个孔，其中较小的孔是所谓的`同步孔`，它不用来存储信息，真正存储信息的是另外八个孔的位置。其中打了孔的位置可以表示`1`，没有打孔的位置可以表示0，这样纸带的一行可以记录8个二进制位，也就是1个字节的信息
    
    有一个专门读取这个纸带的机器，将它所记载的信息写到RAM中，就完成了程序的输入（它的原理其实类似我们在考试时用2B铅笔涂选择题的选项）
    
    对比之前将程序手工输入到RAM，采用`穿孔纸带`将程序输入到RAM中的优势十分明显，那就是我们只需要将程序输入到纸带上一次，之后该纸带就可以被重复利用，而无需每次运行程序时都重新输入一遍
    
    后来出现了非易失性存储设备，我们可以将程序存储到大容量的flash存储器或者磁盘（这些就是所谓的辅助存储器，我们稍后唠叨）上。而这些大容量存储设备的访问速度实在太慢了，所以CPU一般不直接从它们中读取指令
    
    不过RAM是易失性存储器，在关闭电源的时候RAM中存储的数据都将丢失，而计算机在开机时就需要从某个地方获取指令，这时候RAM中是没有数据的，所以一般采用一块容量较小的ROM芯片来存储开启启动程序，CPU直接从这个ROM中读取必要的指令，这些指令完成的一个很重要的功能就是从磁盘这样的大容量存储设备中将我们编写的程序复制到RAM中，然后再执行跳转指令跳转到RAM中执行程序
    
    也就是说实际上CPU运行期间是直接从容量较小的ROM以及RAM中获取指令的，存储引导程序的ROM通常也可以被看作主存的一部分
    
- 辅存
    
    辅助存储器（Secondary Memory），也叫二级存储器，简称辅存，一般使用造价低廉的磁盘、flash存储器（使用flash存储器可以制作人们常说的固态硬盘）来制作
    
    辅存的特点就是容量大、造价低，但访问速度非常慢，现代CPU访问一次磁盘需要上千万个时钟周期。CPU并不直接从辅存中读取指令，而是先成批的将指令和数据加载到主存中，然后再从主存中读取指令并执行它们
    
    这里的“成批”指的是CPU向辅存发起一次读取或写入操作时，并不是只从辅存中读取一个存储单元的数据或写入一个存储单元的数据，而是从辅存中读取或写入成百上千个字节的数据，我们可以把这成百上千个字节的数据称作是一个`块`
    
    辅存会把自己的存储空间分成若干个块，每个块都有唯一的地址，这样CPU在读取或写入数据时，只需要告诉辅存块地址就好了
    
    另外，CPU地址是有限的，如果CPU不需要直接从辅存中读取指令的话，那就没必要将每一个CPU地址都映射到一个磁盘存储空间地址。取而代之的是将辅存当作I/O设备
    
    辅存的控制器中仅提供数量有限的寄存器，然后将某几个CPU地址映射到这些寄存器上。辅存的控制器可以包含：
    
    - 地址寄存器，CPU将要读取或写入的块地址写到该寄存器中
    - 数据寄存器，从辅存中读出或向辅存中写入的数据写到该寄存器中
        
        一个块的数据可能非常大，需要分多次读写数据寄存器
        
    - 状态寄存器，该寄存器用于表明现在辅存的状态是个啥，比方说现在是不是正在忙，CPU要读取的数据是否已经准备好了等等
    - 控制寄存器，该寄存器表明CPU是想从辅存中读取数据还是写入数据，CPU在发起读/写访问的时候要修改该寄存器的值

寄存器、主存、辅存可以搭建起一个金字塔结构的存储体系，如下图所示：

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%92%8CI%20O%E8%AE%BE%E5%A4%87%2089767b595e79430bbf71546fe3ec5d03/Untitled%201.png)

从下往上看，各个存储设备的容量越来越小、但是单比特成本越来越大、访问速度越来越快、使用频率也越来越快。这样子就是一个成本最低，而性能最好的存储器层次结构

### **I/O设备**

程序运行时所需要访问的数据可能并不是在编写程序时就已经准备好的，而是在真正执行程序时由用户输入的, 另一方面，程序的执行结果可以通过store指令再写回到主存中去，可是我们并不能像把脉一样感受到主存的某个存储单元里存储的是什么数据，即便可以读取到某个存储单元的数据也是一串冰冷的二进制数，我们需要显示器、打印机这样的设备能把程序运行过程中产生的数据以人类可以接受的方式展示出来

像鼠标、键盘这样的设备被称作输入设备（Input Device），像显示器、打印机这样的设备称作输出设备（Output Device），它们被统称为I/O设备。另外，像辅存这样的既可以为主存提供数据，也可以接受从主存中写出的数据的设备也可以被看作既是输入设备，也是输出设备

每个I/O设备都可以有它相应的控制器，这个控制器负责和CPU进行交互，如下图所示

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%92%8CI%20O%E8%AE%BE%E5%A4%87%2089767b595e79430bbf71546fe3ec5d03/Untitled%202.png)

上图中我们画了一个支持一主八从的总线模块，该总线模块可以将给定的CPU地址映射到某个具体的从设备中

这样的话，CPU访问I/O设备的方式和访问主存就没什么两样，我们把这样访问I/O设备的方式称作Memory-Mapped I/O，也就是内存映射式I/O。这种内存映射式I/O对于软件程序员来说是非常幸福的，因为我们在写指令的时候不需要考虑目前是在访问主存，还是在访问I/O设备，都使用统一的指令即可

> I/O设备控制器中包含若干寄存器，这些寄存器用于存储当前I/O设备的状态、CPU向I/O设备发送的命令、CPU和I/O设备进行通信的地址和数据等信息。在内存映射式I/O中，我们只需要将CPU地址与这些寄存器进行映射，由于I/O设备包含的寄存器数量较少，所以并不会耗费太多的CPU地址，绝大多数CPU地址还是用于访问主存的
这些I/O设备中的寄存器也可以被称作I/O端口，有的CPU，比方说Intel公司的CPU可以并不将CPU地址映射到这些I/O端口，而是通过提供专门读写I/O端口的指令来访问I/O设备，这样就可以节省下更多的CPU地址用于访问主存。其他的CPU多采用内存映射式I/O来访问I/O设备
> 

以键盘为例来说明一下CPU如何使用内存映射式I/O读取从键盘输入的数据，CPU从键盘中读取数据至少需要知道两个方面的内容：

- 键盘中有没有按键被按下
- 如果有按键被按下，那被按下的是哪个键

针对上边两个内容，我们可以在键盘控制器中制作两个寄存器：

- key_valid寄存器。当有按键被按下时，键盘对应的电路就告知键盘控制器有按键被按下，就将key_valid寄存器的值设置为1
- key_value寄存器。键盘上的每一个键都可以对应一个数值，这是我们在设计键盘电路的时候就预先分配好的，比方说'Q'键对应97，'W'键对应103等等。当有按键被按下时，键盘对应的电路同时告知键盘控制器哪个键被按下了，key_value寄存器把该键对应的数值保存下来

为读取这两个寄存器，总线模块需要分配至少2个地址给键盘控制器，我们这里假设把50、51这两个地址分配给键盘控制器，那么

- 当CPU发起读操作，将50放到地址线上，并将CPU_WE_O=0、CPU_HELLO_O=1，表示要读数据了。当键盘控制器收到请求后，就会将key_valid寄存器的内容放到数据线上，并向CPU发送一个ACK信号，表示数据已经准备好了
- 当CPU发起读操作，将51放到地址线上，并将CPU_WE_O=0、CPU_HELLO_O=1，表示要读数据了。当键盘控制器收到请求后，就会将key_value寄存器的内容放到数据线上，并向CPU发送一个ACK信号，表示数据已经准备好了。当CPU读取完数据后，键盘控制器可以将key_valid设置为0，以等待后续键盘输入

那么CPU可以先读取key_valid寄存器的值，如果该寄存器的值是1，表示现在有按键按下，再去读key_value寄存器的值就好；如果key_valid寄存器的值是0，表示现在没有键按下，CPU可以决定放弃读取键盘输入转而去做别的事情，也可以继续循环读取key_valid寄存器的值，直到该寄存器的值为1为止（这取决于我们怎样编写软件指令)

上述的“循环读取key_valid寄存器的值，直到该寄存器的值为1为止”的过程也被称作`轮询`
，就是不停的询问的意思，可以想象CPU不停的在询问键盘控制器：“嘿，你准备好数据了吗”，键盘控制器说：“还没呢，等会儿你再来”，然后CPU转头就继续问：“嘿，你准备好数据了吗”，键盘控制器说：“不是刚说了没好么，等会儿你再来”，话音未落，CPU就继续问：“嘿，你准备好数据了吗”，键盘控制器：“***%*&#(*#&@，你是听不懂人话吗，我说没好，你等会儿再来”。CPU继续问...

可以看到，轮询的后果就是CPU一直在不厌其烦的问控制器数据准备好了没，这时CPU就不能去干别的事了，效率是十分低的，有没有一种方式是每当有按键被按下时，键盘控制器主动通知CPU说：“老兄，有人按了一下键盘，按键是XXX，你方便的时候处理一下哈”。CPU收到这个消息之后，可以转而先处理一下键盘控制器的通知，处理完了回去做之前在做的事情。这个功能就是所谓的`中断`
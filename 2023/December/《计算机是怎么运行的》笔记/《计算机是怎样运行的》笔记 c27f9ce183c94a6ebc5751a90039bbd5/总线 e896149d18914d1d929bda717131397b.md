# 总线

RAM 负责存储指令和数据，而软件开发程序员只需要将指令和数据事先保存到 RAM 中，然后 CPU就可以逐条执行指令了，并且还可以把程序执行结果再写回到 RAM 中

RAM 的全称是 Random Access Memory，也就是`随机访问存储器`，其中的`随机`
指的是访问任意地址对应的数据所需时间是相同的。RAM其实可以分为两种：

- 读/写存储器（Read/Write Memory，简称RWM）
既支持读、也支持写的存储器。
- 只读存储器（Read-Only Memory，简称ROM）
只支持读、不支持写的存储器。

出于历史的原因，导致涉及存储器的诸多概念出现了多种含义，在现实生活中，RAM和ROM的含义并不像它们的名字那样单纯。

平时谈到`RAM`时，通常是指数据会在断电后就丢失、并支持随机访问的读/写存储器。而在谈到`ROM`时，通常是指断电后数据并不丢失、并支持随机访问的存储器. 实际上随着技术的进步，后续出现的诸多ROM其实是支持写入数据的

可以看到，其实RAM和ROM的最大区别其实是断电后数据是否丢失，所以把它们称作易失性（volatile）存储器和非易失性（nonvolatile）存储器感觉更恰当一些

一些制作RAM的方式：使用寄存器来制作RAM，后来又介绍了使用6个晶体管存储一位数据的SRAM，还有一个晶体管加一个电容存储一位数据的DRAM

- 掩模ROM
掩模ROM在制作完成后，该ROM中保存的数据就不会再变了，属于名副其实的只读存储器
    
    > 在制作晶体管时，会首先在原材料上涂抹一层感光材料。然后制作一个板子，像剪纸一样在板子上扣出各式各样的形状（其实就是电路图对应的形状），再把刻好的板子放到原材料上，之后用光照射。这样光只能照射到板子上被扣出去的那部分，那么原材料上对应部位的感光材料就被光给照掉了，这一部分工艺称作光刻。其中的那个板子也可以被称作掩模板，而掩模ROM中的数据其实是在制作掩模板的时候就决定了，所以就被称作掩模ROM
    > 
- PROM（Programmable Read-Only Memory）
可编程只读存储器。掩模ROM在出厂后数据就无法更改，但实际工作中有很多同学想自定义ROM中的内容，让厂家去定制掩模板的成本又太高，所以后续就推出了PROM。对于PROM来说，它内部包含了一些称为`熔丝`或者`反熔丝`的东西。在第一次也是最后一次修改PROM中存储的数据时，会采用破坏掉`熔丝`或者`反熔丝`来达到改变它内部数据的目的。这种破坏是不可修复的，所以我们只有一次修改它保存的数据的机会
- EPROM（Erasable Programmable Read-Only Memory）
    
    可擦除的可编程只读存储器。这是一种可用紫外线照射进行数据擦除的ROM，它可以进行多次写入，但每次重新写入数据时需要照很长时间的紫外线
    
- EEPROM （Electrically Erasable Programmable Read-Only Memory）
    
    电信号擦除的可编程只读存储器。向EPROM中写入数据十分不便，需要单独的紫外线光照才能清除它的数据，而EEPROM是使用提高输入电压的方式完成数据的写入，而且写入数据的时间也大大降低
    
- 快闪存储器（Flush Memory）
快闪存储器是对EPROM、EEPROM的进一步改进，使它的集成度更高，也就是在单位面积上可以存储更多的数据，而且相较于EEPROM，写入数据时可以使用更低一点儿的电压

这些ROM和RAM，它们内部都是用晶体管制作的，可以被统称为`半导体存储器`。除了半导体存储器，人们使用了别的材料制作了一些存储设备，比方说：

- 磁性材料 比方说生活中常见的磁带、磁盘。
- 光学材料 比方说生活中常见的光盘

不论是什么样的存储设备，它的功能就是用来存储数据的，它们所存储的数据可以以一个或多个比特位为一组来进行编址，也就是每一组数据都对一个唯一的一个地址，外界可以通过地址来访问该地址对应的数据
但是不同的存储设备的运行机制是不一样的，比方说DRAM就要求外界给它提供周期性刷新、预充电等信号，CPU如果直接和这些存储设备打交道的话成本会非常高（也就是CPU的设计会非常复杂），所以针对不同的存储设备，我们都可以制作一个相应的控制器，CPU发送给不同控制器的请求是相同的，然后再由控制器去处理和实际存储设备之间的复杂交互

### **CPU和存储设备的交互**

CPU和RAM进行交互，可以通过`RAM控制器`作为中介，我们忽略时钟信号和复位信号后，CPU和RAM的通信示意图可以画成这样：

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled.png)

如果我们把指令和数据不放在RAM中，而是放在快闪存储器中，然后再制作一个`Flush控制器`
（Flush Controller，简称FC）作为CPU与快闪存储器之间的`中介`，那么CPU和快闪存储器的通信示意图就可以画成这样

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%201.png)

我们也可以把指令和数据放在磁盘里，然后再制作一个`磁盘控制器`（Disk Controller，简称DC）作为CPU与磁盘之间的`中介`，那么CPU和磁盘的通信示意图就可以画成这样：

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%202.png)

CPU也可以通过`ROM控制器`（可以简称为ROMC）来访问掩模ROM，如下图所示：

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%203.png)

不论我们把指令和数据存储到啥类型的存储器中，CPU和外界联系的信号线都不需要改变！这也就意味着我们的CPU做好了就不用再变了，CPU并不关心它所需要的指令和数据到底是来自哪里，如果之后有更换存储器的需求，那换一下和CPU交互的控制器就好了

但是这里边有一个巨大的不方便的地方，那就是CPU一次只能和一种存储设备进行交互，如果CPU想和多个存储设备进行交互，那就得不停的换和CPU连接的控制器，这也太麻烦了

能不能将CPU和这些存储设备一次性都连起来，然后给不同的存储设备分配不同的地址范围，然后我们在编写软件指令的时候，只要指定不同的地址就可以访问不同存储器中的数据呢

比方说现在CPU想和掩模ROM、RAM、快闪存储器和磁盘这4个存储设备进行通信，而CPU的地址线一共有6根，对应6个二进制位，能表示的地址范围就是`000000₂～111111₂`，也就是十进制的0~63，共64个地址。CPU输出的地址共有6个二进制位，那它的地址信号线就可以被写成CPU_ADDR_O[5:0]，我们可以人为的将这6个二进制位分成两个部分

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%204.png)

如图所示：

- 第1部分：前2个二进制位，也就是CPU_ADDR_O[5:4]， 用于标记要访问哪个存储设备
    
    我们可以这样规定：
    
    1. 当CPU_ADDR_O[5:4]=00₂时，CPU要访问掩模ROM
    2. 当CPU_ADDR_O[5:4]=01₂时，CPU要访问RAM
    3. 当CPU_ADDR_O[5:4]=10₂时，CPU要访问快闪存储器
    4. 当CPU_ADDR_O[5:4]=11₂时，CPU要访问磁盘
- 第2部分：后4个二进制位，也就是CPU_ADDR_O[3:0]， 是存储设备真正接收到的地址

这样的话，CPU的地址就可以被划分成如下4个部分

- `000000₂～001111₂`，也就是十进制的0～15：划分到掩模ROM中，掩模ROM实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15
- `010000₂～011111₂`，也就是十进制的16～31：划分到RAM中，RAM实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15
- `010000₂～011111₂`，也就是十进制的16～31：划分到RAM中，RAM实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15
- `110000₂～111111₂`，也就是十进制的48～63：划分到磁盘中，磁盘实际接收到的地址是`0000₂～1111₂`，也就是十进制的0～15

综上所述，CPU的这64个地址的划分就如下图所示：

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%205.png)

那么：

- 如果CPU执行`load_m 0`指令，那就是要读取掩模ROM中地址为0的数据
- 如果CPU执行`load_m 16`指令，那就是要读取RAM中地址为0的数据
- 如果CPU执行`load_m 32`指令，那就是要读取快闪存储器中地址为0的数据
- 如果CPU执行`load_m 48`指令，那就是要读取磁盘中地址为0的数据

只需要通过修改软件指令的方式就可以让CPU访问不同的存储器，而不用费劲的用替换控制器的这种改硬件的方式让CPU访问不同的存储器, 制作这个设备需要解决下边这几个问题

- 问题一：各个控制器接收到的HELLO_I信号如何生成？
    
    CPU一次只能访问一个存储设备，它是通过发出CPU_HELLO_O信号来表明自己要发起读/写访问了，那么我们需要：
    
    - 当CPU_ADDR_O[5:4]=00时，也就是在访问掩模ROM时，我们需要让ROMC_HELLO_I与CPU_HELLO_O相同，其余控制器的HELLO_I信号均为逻辑0
    - 当CPU_ADDR_O[5:4]=01时，也就是在访问RAM时，我们需要让RC_HELLO_I与CPU_HELLO_O相同，其余控制器的HELLO_I信号均为逻辑0
    - 当CPU_ADDR_O[5:4]=01时，也就是在访问RAM时，我们需要让FC_HELLO_I与CPU_HELLO_O相同，其余控制器的HELLO_I信号均为逻辑0
    - 当CPU_ADDR_O[5:4]=11时，也就是在访问磁盘时，我们需要让DC_HELLO_I与CPU_HELLO_O相同，其余控制器的HELLO_I信号均为逻辑0
    
    还记得之前我们制作简易RAM时所用到的`2-4译码器`么：
    
    ![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%206.png)
    
    这个译码器完成的功能是：
    
    - 当`S₁S₀=00`时，WE0=1，其余WE信号均为0。
    - 当`S₁S₀=01`时，WE1=1，其余WE信号均为0。
    - 当`S₁S₀=10`时，WE2=1，其余WE信号均为0。
    - 当`S₁S₀=11`时，WE3=1，其余WE信号均为0
    
    我们可以借助这个`2-4译码器`来生成各个控制器的HELLO_I信号，如下图所示：
    
    ![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%207.png)
    
- 问题二：CPU的CPU_ACK_I信号如何生成？
    
    由于各个控制器都会生成ACK_O信号，CPU该选择哪个作为CPU_ACK_I呢？当然是CPU现在在访问哪个设备，就接收哪个设备的ACK_O信号喽，也就是：
    
    - 当CPU_ADDR_O[5:4]=00时，也就是在访问掩模ROM时，CPU_ACK_I与ROMC_ACK_O相同
    - 当CPU_ADDR_O[5:4]=01时，也就是在访问RAM时，CPU_ACK_I与RC_ACK_O相同
    - 当CPU_ADDR_O[5:4]=10时，也就是在访问快闪存储器时，CPU_ACK_I与FC_ACK_O相同
    - 当CPU_ADDR_O[5:4]=11时，也就是在访问磁盘时，CPU_ACK_I与DC_ACK_O相同
    
    这不就相当于从4个信号（ROMC_ACK_O、RC_ACK_O、FC_ACK_O、DC_ACK_O）中选择一个信号（CPU_ACK_I）么，很显然使用`4-1选择器`即可解决这个问题
    
    ![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%208.png)
    
- CPU收到的数据输入CPU_DATA_I是什么？
    
    由于各个控制器都会生成DATA_O信号，CPU该选择哪个作为CPU_DATA_I呢？当然是CPU现在在访问哪个设备，就接收哪个设备的DATA_O信号喽，也就是：
    
    - 当CPU_ADDR_O[5:4]=00时，也就是在访问掩模ROM时，CPU_DATA_I与ROMC_DATA_O相同。
    - 当CPU_ADDR_O[5:4]=01时，也就是在访问RAM时，CPU_DATA_I与RC_DATA_O相同。
    - 当CPU_ADDR_O[5:4]=10时，也就是在访问快闪存储器时，CPU_DATA_I与FC_DATA_O相同。
    - 当CPU_ADDR_O[5:4]=11时，也就是在访问磁盘时，CPU_DATA_I与DC_DATA_O相同
    
    这不就相当于从4个信号（ROMC_DATA_O、RC_DATA_O、FC_DATA_O、DC_DATA_O）中选择一个信号（CPU_DATA_I）么，很显然使用`4-1选择器`即可解决这个问题
    
    ![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%209.png)
    
- 其他的信号怎么办？
    
    站在控制器的角度看，它们的DATA_I、WE_I均可以来自CPU的CPU_DATA_O、CPU_WE_O，另外，所有控制器的ADDR_I都是CPU输出的地址信号的后4位，也就是CPU_ADDR_O[3:0]
    
    有同学会想各个控制器都收到同样的DATA_I、WE_I以及ADDR_I会不会有什么问题？没什么问题，因为控制器决定要不要真正的访问存储器依赖的是HELLO_I信号，如果HELLO_I信号保持为逻辑0，即使收到别的信号，那它也什么都不用做
    

综上所述，CPU和各个控制器以及存储设备之间的连接关系最后应该如下图所示

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%2010.png)

把CPU和各个控制器连接的部分装到黑盒子里去，就像这样：

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%2011.png)

上图中黑色背景的部分也被称作总线（Bus）模块，简化一下的示意图如下所示：

![Untitled](%E6%80%BB%E7%BA%BF%20e896149d18914d1d929bda717131397b/Untitled%2012.png)

在使用总线模块进行通信的各个设备中，发起读/写请求的设备称作主（Master）设备，接收读/写请求的设备称作从（Slave）设备。再上图的例子中，CPU是我们唯一的主设备，ROM控制器、RAM控制器、Flash控制器和磁盘控制器作为从设备，我们也可以说上图中的总线模块是一个支持1主4从的总线模块

以我们上边的电路图来说，如果你要开发自己的主设备，并且可以让主设备发起读操作的话，那就必须在发起读操作的那个时钟周期完成下边这些事情：

- 需要在CPU_ADD_O上指定地址
- 令CPU_WE_O=0
- 令CPU_HELLO_O=1

之后就可以进入等待状态，直到CPU_ACK_I=1，主设备就可以读取CPU_DATA_I的数据，取到数据之后再进行下一步操作

类似的，你要开发自己的从设备，也要遵守相应的规则，我们把主设备和从设备之间的通信规则也叫做总线协议，我们需要遵守总线协议来开发自己的主设备和从设备

目前开发的这个总线模块是十分简单的，它只支持1个主设备，内部由一些组合电路构成。如果要开发支持多个主设备的总线模块的话，当多个主设备同时发起读/写请求的时候，总线模块还需要负责决定哪个主设备先进行读/写操作，哪个主设备后进行读/写操作，总线模块中完成这个功能的部分称作`总线仲裁器`。这个时候总线模块就不能是简单的组合电路了，里边应该由更复杂的时序电路组成

> 其实支持多主多从的总线模块还是很有用的，比方说我们有两个CPU，这两个CPU可以访问相同的存储设备，这时就可以将两个CPU和其他存储设备和支持多主多从的总线模块连接。我们写的软件指令可以放到存储设备中被两个CPU执行，效率不就翻倍了么！这其实就是所谓的多核CPU
>
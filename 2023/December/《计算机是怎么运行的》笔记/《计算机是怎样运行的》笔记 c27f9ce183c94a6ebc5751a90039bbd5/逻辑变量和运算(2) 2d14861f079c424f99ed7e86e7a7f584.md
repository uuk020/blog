# 逻辑变量和运算(2)

如果我们使用4个二进制位表示数字，那能表示的数字范围就是：`0000₂~1111₂`，共16（$2^4$）个数字

`1111₂`是能表示的最大的数字，如果我们给`1111₂`再加1会发生什么？当然结果会变成`10000₂`，但是已经规定使用4个二进制位表示数字，那就需要忽略掉加数中最高有效位相加得到的进位，导致结果成为了`0000₂`

我们在现实生活中有这种走着走着就从头开始的感觉么？秒针走到了59秒的地方之后再走一秒又从0秒开始，分针走到了59分的地方之后再走一分又从0分开始，时针走到了11时的时候再走1个小时就又从0时开始

可以将使用4个二进制位表示的数字放在表盘上，然后画上16个刻度，每个刻度对应一个数字，就像这样：

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled.png)

我们顺便画了一个指针，现在指针指向`0000₂`，表明现在表盘表示的数字就是`0000₂`

我们先将指针顺时针拨动`1111₂`（十进制的`15`）个刻度，然后再顺时针拨动`0001₂`（十进制的`1`）个刻度，那么指针就会指向原先的位置(`0000₂`)，相当于完成了一个轮回，我们就可以说`1111₂`和`0001₂`互为补数. 我们先将指针顺时针拨动`0101₂`（十进制的`5`）个刻度，然后再顺时针拨动`1011₂`（十进制的`11`）个刻度，那么指针就会指向原先的位置(`0000₂`)，也相当于完成了一个轮回，我们就可以说`0101₂`和`1011₂`互为补数。

一般的，在我们规定使用n个二进制位表示数字的时候，**如果两个数之和为2n，那我们称这两个数互为补数**。概念很简单哈，不过千万千万要注意：在讨论补数时一定要限定一下我们当前使用几个二进制位来表示数字

如果我们现在规定使用8个二进制位表示数字，因为`00000101₂`和`11111011₂`（251₁₀）满足下边的关系

00000101₂+11111011₂=100000000₂=$2^8$

我们就说`00000101₂`（5₁₀）和`11111011₂`（251₁₀）在规定使用8个二进制位表示数字时互为补数。从表盘的角度讲，在规定使用8个二进制位表示数字时，此时的表盘上就应该有28，也就是256个刻度，指针从某个位置沿着一个方向转`00000101₂`（5₁₀）个刻度后，继续沿着该方向转`11111011₂`（251₁₀）个刻度正好是一圈，从而回到出发时的位置

### 如何求一个二进制数的补数

使用2n减去这个数， 比方说在我们限定了使用3个二进制位来表示数字之后，如果我们想求`101₂`的补数，那就使用`1000₂`（也就是23）来减去这个二进制数`101`

```markdown
	1000₂
-  101₂
-------- 
   011₂
```

不过这个过程需要使用到借位，如果我们想用更简单的方式计算出结果的话，可以使用下边两个步骤来计算

- 步骤一：使用`111₂`减去`101₂`
    
    ```markdown
    	 111₂
    -  101₂
    -------- 
       010₂
    ```
    
    这个过程不需要使用到借位，可以很轻松的算出`111₂ - 101₂`的结果是`010₂`
    
- 步骤二：然后再将步骤一中的结果加`1`：
    
    ```markdown
    	010₂
    +   1
    -------- 
       011₂
    ```
    
    这个`011₂`就是`1000₂ - 101₂`的差。
    

在我们限定了使用n个二进制位来表示数字之后，可以通过下边两个步骤来求一个二进制数的补数:

- 步骤一：先计算由n个`1`组成的二进制数字（其实也就是`2n - 1`）减去该数的值（此过程不涉及借位）。
- 步骤二：然后将上一步骤的结果加1。

当然，划分成这两个步骤不仅仅是为了让人类在计算时减少借位过程，我们的落脚点还是想让机器来替代我们进行计算。现在重新聚焦于步骤一，如果有一个使用n个二进制位表示的数字：$xn−1​xn−2​⋅⋅⋅x2​x1​x0​$ 我们想求它的补数，那么首先要计算一下由n个`1`组成的二进制数字减去该数的差。其实这一步骤也相当于求$xn−1​xn−2​⋅⋅⋅x2​x1​x0​$ 加上哪个也使用n个二进制位表示的数字之和为由n个`1`组成的二进制数字

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%201.png)

同时我们也知道一个规律：

- 1 + 0 = 1
- 0 + 1 = 1
- 0 + 0 ≠ 1
- 1 + 1 ≠ 1

也就是说如果我们想让两个二进制位相加的和为1，那么这两个二进制位的值肯定不同，要么是`0`和`1`，要么是`1`和`0`。

只需要让$x0$ 作为一个输入信号通过一个反相器，那么就可以得到与它不同的信号.

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%202.png)

所以总结一下计算某个二进制数的补数的过程就是：将该二进制数中的每一个二进制位都做取反操作，然后再加1，我们可以把这个过程简称为`取反加1`

### 利用补数将减法转换为加法

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%203.png)

也就是说：在做使用n个二进制位表示的数字之间的减法操作时，减去一个数等于加上这个数的补数然后再减去2n，减去2n的操作其实就相当于直接把两个加数的最高有效位相加（在进行最高有效位相加时，也需要考虑到前一位相加时的进位）时的进位忽略掉，得到的就是原减法的结果

这个事情在表盘上可以有更直观的体现，比方说现在规定使用4个二进制位表示数字，现在指针指向`1000₂`（8₁₀），如果我们想在`1000₂`（8₁₀）的基础上减去`0011`（3₁₀），那么可以采用两种方案

- 将指针逆时针拨3（`0011₂`）个刻度
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%204.png)
    
- 将指针顺时针拨13（`1101₂`）个刻度
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%205.png)
    
    我们可以把逆时针拨动指针当作是在做减法，顺时针拨动指针当作做加法，很显然，逆时针拨动$x$个刻度，就相当于顺时针拨动$2^4 - x$个刻度, 也就是说在使用固定个数的二进制位表示数字时，减去一个数和加上这个数的补数的效果是相同的
    
- 假设x的值为`11010111₂`（215₁₀），y的值是`10010001₂`（145₁₀），我们想求`x - y`的差是多少
    
    ```bash
    	11010111₂   //x的值是11010111₂
    - 10010001₂   //y的值是10010001₂
    ------------ 
             ?
    ```
    
    首先通过`取反加1`的方式计算出`10010001₂`（145₁₀）的补数是`01101111₂`（111₁₀），然后将被减数`11010111₂`（215₁₀）和`01101111₂`（111₁₀）相加
    
    ```bash
    	11010111₂
    + 01101111₂
    ------------ 
     101000110₂
    ```
    
    然后减去`100000000₂`（也就是$2^8$），减去`100000000₂`的操作也可以相当于把两个加数的最高有效位相加的进位忽略，得到如下结果：
    
    ```bash
    01000110₂
    ```
    
    也就是说`x - y`的差就是`01000110₂`（70₁₀）。
    
- 假设x的值为`11010111₂`（215₁₀），y的值是`101101₂`（45₁₀），我们想求`x - y`的差是多少，就像这样
    
    ```bash
    	11010111₂   //x的值是11010111₂
    -   101101₂   //y的值是101101₂
    ------------ 
             ?
    ```
    
    因为`101101₂`（45₁₀）是使用6个二进制位表示的，所以我们先把它扩展为使用8个二进制位表示的形式（其实就是在数字前加前缀`0`），所以减法看起来就是这样
    
    ```bash
    	11010111₂   //x的值是11010111₂
    - 00101101₂   //y的值是101101₂
    ------------ 
             ?
    ```
    
    首先通过`取反加1`的方式计算出`00101101₂`（45₁₀）的补数是`11010011₂`（211₁₀），然后将被减数`11010111₂`（215₁₀）和`11010011₂`（211₁₀）相加
    
    ```bash
    	11010111₂
    + 11010011₂
    ------------ 
     110101010₂
    ```
    
    然后减去`100000000₂`（也就是28），减去`100000000₂`的操作也可以相当于直接把两个加数的最高有效位相加的进位忽略，得到如下结果
    
    ```bash
    10101010₂
    ```
    

### 使用电路解决二进制减法问题

在做使用n个二进制位表示的数字之间的减法操作时，减去一个数等于加上这个数的补数然后再减去2n，减去2n的操作其实就相当于直接把两个加数的最高有效位相加时的进位忽略掉，得到的就是原减法的结果

现在要计算两个8位二进制数的差，被减数是$A₇A₆A₅A₄A₃A₂A₁A₀$ , 减数是 $B₇B₆B₅B₄B₃B₂B₁B₀$ 其中`An`和`Bn`（n是`0~7`之间的整数）分别代表一个二进制位。那么将这个减法转换为加法的关键就是求得减数的补数之后再和被减数相加,求一个二进制数补数的过程我们上边都已经说过了，就是：`取反加1`。“取反”我们已经说过了，就是简单将每一个二进制位作为输入信号通过一个反相器罢了，但是该如何实现“加1”呢？

哈哈，还记得我们前边介绍`n位加法器`的时候留了一个悬念么，就是在处理`A₀`和`B₀`这两个二进制位加法的时候采用的是全加器，而不是半加器（只不过该全加器的进位输入`Cin`的值为0）。此时我们只要让8位加法器的进位输入`Cin`的值设置为1，即可实现“加1”效果

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%206.png)

这样得到的`S₇S₆S₅S₄S₃S₂S₁S₀`就是最后的差。

如果我们之后想计算`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`的和，那我们还需要手动地把对`B₇B₆B₅B₄B₃B₂B₁B₀`做取反操作的反相器再都去掉，然后把进位输入`Cin`的值调整为`0`。

- 当进位输入`Cin`的值为`0`时，此时表示想对`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`做加法运算，并不打算对`B₇B₆B₅B₄B₃B₂B₁B₀`做取反操作
- 当进位输入`Cin`的值为`1`时，此时表示想对`A₇A₆A₅A₄A₃A₂A₁A₀`与`B₇B₆B₅B₄B₃B₂B₁B₀`做减法运算，需要对`B₇B₆B₅B₄B₃B₂B₁B₀`做取反操作

也就是说针对`B₇B₆B₅B₄B₃B₂B₁B₀`中的任意一个位`Bn`，我们都期望

- 当进位输入`Cin`的值为`0`时，`Bn`的值保持不变
- 当进位输入`Cin`的值为`1`时，对`Bn`的值做取反操作

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%207.png)

这不就是`异或门`的真值表嘛！也就是说只要我们将进位输入`Cin`和`Bn`作为异或门的两个输入信号，就可以得到期望的结果。说干就干，继续改进一下`n位加法器`，使它既支持加法也支持减法

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%208.png)

二进制数其实都是若干个0或者1这两个符号之间的任意组合，符号所在位置的不同，所代表的数值大小也不同，每个位置的符号表示的数值为该符号的字面量乘以该位置的权重（2的整数次幂），整个组合表示的数值为所有位置的符号代表的值加起来的总和。如果大家仔细琢磨的话，就会发现按照这样解释符号组合代表的数值的方式是无法表示负数的，所以我们也把通过这样的方式来解释数值的符号组合称为`无符号数`

两个`无符号数`在运算之后得到的结果自然也将其理解为`无符号数`。这样就产生了一个问题，如果两个无符号数相减，在减数比被减数大的时候理论上应该产生负数，可是现在我们无法使用`无符号数`表示负数，这种情况就比较尴尬

我们需要注意：在使用n个二进制位表示无符号数时，多个无符号数参与算术运算时的运算结果不应该小于0，也不应该大于$2^n-1$，否则得到的结果将不是我们想要的

### 有符数

其实由若干个0和1组成的符号组合仅仅是个符号组合，只不过我们可以人为地赋予它代表某个数值的含义罢了。如果我们规定使用4个二进制位表示数字，那么就一共可以形成16种符号组合

如果我们把这些符号组合当作`无符号数`来理解，我们就可以把符号组合`0000₂`映射到数值`0`，`0001₂`映射到数值`1`，`0010₂`映射到数值`2`，`0011₂`映射到数值`3`，以此类推，`1110₂`映射到数值`14`，`1111₂`映射到数值`15`，我们把这些符号组合映射到的数值也画到表盘上

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%209.png)

我们说在使用n个二进制位表示数字时，假设$y$,  $y'$ 是两个使用n个二进制位表示的数字，它们互为补数，那么我们有:

$$
y + y' = 2^n
$$

$2^n$用二进制数表示的话其实就是`1`后边跟上`n`个`0`，也就是需要`n+1`个二进制位来表示这个数字，而我们规定了只使用n个二进制位来表示数字，所以相当于需要把最左边的1舍弃掉，结果和`0`相同。也就是说下边的式子在使用n个二进制位来表示数字时是成立的

$$
y + y' = 0
$$

两个数互为相反数的时候加和结果为0，这也就意味着我们其实可以直接使用一个数的补数来表示与它对应的相反数, 比如我们现在使用4个二进制位的符号组合来表示数字，如果说我们给某个数加上`0001₂`，相当于在表盘上顺时针转1个刻度，其实也相当于逆时针转15个刻度, 我们前边说顺时针转相当于做加法，逆时针转相当于做减法，也就是说`0001₂`其实可以表示正数`1`，也可以表示负数`15`。同理，我们也可以让`0010₂`表示`14`、`0011₂`表示`13`、`0010₂`表示`12`...`1110₂`表示`2`、`1111₂`表示`1`，现在我们就可以改进一下符号组合和数值之间的映射关系了

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%2010.png)

如果我们采用这样子的映射关系来解释符号组合的数值，那么对于下边的这个式子:

```bash
0101₂ + 1110₂ = 0011₂（省略掉了进位）
```

就可以解释成：先将指针从`0000₂`的位置逆时针转动11个刻度，再逆时针转动2个刻度，就到达了`0011₂`刻度（`0011₂`表示负数`13`）

不过这样的话4个二进制位能表示的数值范围就成了十进制的`15～0`，在做运算的时候得保证结果的数值也在这个范围之内。这样子有个问题，就是不能表示正数啦！我们还是希望能这些符号组合能表示一部分正数，也能表示一部分负数，这样子才最符合日常所需

- `0000₂～0111₂`这8个符号组合为一组，它们代表非负数，它们代表的数值大小与对应的无符号数相同。这一组的首个二进制位都是`0`
- `1000₂～1111₂`这8个符号组合为一组，它们代表负数，它们的绝对值和它们对应的补数相同。这一组的首个二进制位都是`1`

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(2)%202d14861f079c424f99ed7e86e7a7f584/Untitled%2011.png)

如果我们采用这样子的映射关系来解释符号组合的数值，那么对于下边的这个式子

```bash
0101₂ + 1110₂ = 0011₂（省略掉了进位）
```

就可以解释成：先将指针从`0000₂`的位置顺时针转动5个刻度，再逆时针转动2个刻度，就到达了`0011₂`刻度（`0011₂`表示正数数`3`）

这样当首个二进制位为0的话，我们就把该数当作非负数对待；首个二进制位为1的话，我们就把该数当作负数对待。因为首个二进制位可以区分这个数是正数还是负数，所以该二进制位也可以被称为`符号位`

对于同一个符号组合，比方说`1111₂`，你说它到底是表示无符号数中的`15`呢，还是表示有符号数中的`1`呢？这个取决于我们人类怎么看它，我们说`1111₂`代表无符号数，它代表的数值就是`15`，我们说`1111₂`代表有符号数，它代表的数值就是`1`

一般地，对于使用n个二进制位表示的有符号数，它代表的数值大小需要按照下边的规则去判断

- 如果符号位的字面量为`0`，那么我们就把它当作是一个非负数
- 如果符号位的字面量为`1`，那么我们就把它当作是一个负数，它的绝对值和它对应的补数相同

特别要注意在使用这些有符号数进行算术运算的时候，得到的结果千万不可以超出取值范围，比方说我们在使用4个二进制位表示数字时，想以有符号数的形式计算数值`3`和`5`的和，数值`3`和`5`在有符号数中的形式分别是`0011₂`和`0101₂`，那么我们可以这样计算

```bash
0011₂ + 0101₂ = 1000₂
```

得到的结果`1000₂`代表的有符号数数值就是`8`，两个正数的和竟然是一个负数，这显然是不对的。原因就是使用4个二进制位表示数字时，能表示的有符号数的取值范围是`8～7`，无法表示正数`8`

### 扩展数字位数

对于使用n个二进制位表示的数字来说，无符号数的取值范围就是：`0～2n1`，有符号数的取值范围就是：`2n-1～2n-11`

使用越少的二进制位来表示数字时，能表示的数值范围就越小；使用越多的二进制位来表示数字时，能表示的数值范围就越大

在我们使用较多的二进制位来表示某个数值时，可能无法使用更少的二进制位来表示这个数值；相反的话，在我们使用较少的二进制位来表示某个数值时，那么一定能使用更多的二进制位来表示这个数值

我们想将使用较少的二进制位表示的无符号数扩展成使用更多二进制位表示的无符号数，只需要在开头补更多的0，比方说使用4个二进制位表示的无符号数`1101₂`（13₁₀），如果我们想

- 把它扩展成使用5个二进制位表示的无符号数，简单地在开头补1个0就好，变成这样：`01101₂`
- 把它扩展成使用6个二进制位表示的无符号数，简单地在开头补2个0就好，变成这样：`001101₂`
- 把它扩展成使用7个二进制位表示的无符号数，简单地在开头补3个0就好，变成这样：`0001101₂`
- 把它扩展成使用n(n>4)个二进制位表示的无符号数，简单地在开头补`n-4`个0就好

可以把这种扩展方式称之为`零扩展`，在原无符号数开头简单地补0，并不会改变它代表数值的大小

如果某个有符号数表示的数值是一个负数，那就不能简单的在原数前边补0了。比如我们使用4个二进制位表示有符号数`1010₂`，它的符号位为`1`，说明它代表的是一个负数，`1010₂`的补数是`0110₂`，而`0110₂`代表十进制的`6`，所以`1010₂`就代表十进制中的`6`。如果我们想使用5个二进制位表示有符号数`1010₂`（-6₁₀），要是直接在开头补0的话就变成了：`01010₂`，因为对于使用5个二进制位表示的这个有符号数来说，它的符号位是`0`，所以`01010₂`实际代表正数`10₁₀`，这可不是我们期望的

假设现在有一个包含4个二进制位的有符号数：`1XXX₂`（其中`X`代表0或1均可），很显然`1XXX₂`的符号位为1，那么`1XXX₂`表示的就是一个负数。我们假设它的补数为`0YYY₂`（其中Y也可以代表0或1），那么我们就有：

```bash
1XXX₂ + 0YYY₂ = 10000₂
```

如果我们想将`1XXX₂`扩展为使用5个二进制位表示的有符号数，那就相当于求`0YYY₂`在使用5个二进制位表示的时候，对应的补数是什么。`0YYY₂`是一个非负数，把它扩展为5个二进制位便很容易，直接在开头补0即可：`00YYY₂`，那么现在的问题就是在求`00YYY₂`对应的补数是什么

我们现在有：

```bash
01XXX₂ + 00YYY₂ = 10000₂
```

在上边的等式两边都加上`10000₂`，就变成了：

```bash
01XXX₂ + 00YYY₂ + 10000₂ = 10000₂ + 10000₂ =  100000₂
```

也就是：

```bash
01XXX₂ + 00YYY₂ + 10000₂ = 100000₂
```

先计算`01XXX₂`与`10000₂`的和：

```bash
(01XXX₂ + 10000₂) + 00YYY₂ = 100000₂
```

也就是：

```bash
11XXX₂ + 00YYY₂ = 100000₂
```

很显然，在使用5个二进制位表示数字时，`00YYY₂`的补数就是`11XXX₂`，而`11XXX₂`正是在原有符号数`1XXX₂`前边补一个1得到的

也就是说，扩展表示有符号数的二进制位个数的时候，需要根据原有符号数的符号位来做不同的操作

- 在原有符号数的符号位为0的时候，可以采用直接在原数前边补0的方式扩展
- 在原有符号数的符号位为1的时候，可以采用直接在原数前边补1的方式扩展。
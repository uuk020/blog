# 处理器和 RAM 的矛盾

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled.png)

它们分别是:

- 第1部分：获取和执行指令的部分。
    
    这个部分是整个电路的灵魂部分，我们也可以将其称作`处理单元`（英文名 Process Unit，简称PU），或者`处理器`（英文名：processor）。其实计算机中也可以有别的某些专门用途的处理单元，比方说专门处理图形和图像计算的处理单元，为了和其他专门用途的处理单元做区分，我们目前做的这个处理单元也可以被称作中央处理单元，也就是Central Process Unit，简称CPU。我们可以用黑盒子将CPU包起来（我们忽略了HALT信号的处理）：
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%201.png)
    
    用黑盒子包装起来的CPU也可以被称为一个`芯片`（chip），该芯片与外界通信的信号线也可以被称作该芯片的`引脚`（引脚）。可以看到我们重命名了CPU的输入输出信号名称，其中后缀为_I表示输入信号，后缀为_O表示输出信号，之后介绍的信号也都遵循此规范
    
    其中各个信号的含义如下表所示：
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%202.png)
    
- 第2部分: RAM, 用于保存指令和数据
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%203.png)
    
    RAM也可以以单独芯片的形式出现， 其中各个信号的含义如下表所示：
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%204.png)
    

CPU和RAM的连接方式如下图所示：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%205.png)

**CPU和RAM速度不匹配的问题**

虽然搭建电路的过程是复杂的，但结果是很美好的，我们费了半天劲其实主要就是搭建起来了CPU和RAM这两个模块。作为用户的我们只需要将指令和数据事先输入到RAM中，然后CPU就可以从RAM中取指令，之后执行指令，然后取下一条指令，再执行，再取指令，再执行... 直到取到halt指令为止。

> CPU能做的事情是如此的简单：取指令、执行指令、取指令、执行指令... 循环往复。
> 

下一步就是要增加RAM的容量，让它可以存储更多的指令和数据，这样才能支持编写更大规模的软件（即程序）。可是增加RAM容量的时候遇到了一些问题

还记得我们之前是如何搭建容量为`4×8`的RAM的吗？我们来看一下电路图：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%206.png)

使用4个8位寄存器来保存数据，每一个寄存器都对应一个专门的地址，然后可以

- 在读取数据时，我们将RAM当作是一个`组合电路`来看待。将地址信号作为`4-1选择器`的控制信号，然后就可以输出该地址对应寄存器中的数据
- 在写入数据时，我们将全局的WE信号设置为逻辑1，然后将地址信号作为`2-4译码器`的输入，就可以将该地址对应寄存器的WE信号设置为逻辑1，从而在下一个时钟信号上升沿到来后修改该寄存器中的数据

在RAM容量较小的时候采用这种方式制作RAM也没有什么问题，但是随着容量的增大问题就会越来越多，比方说

- 寄存器是一个十分耗费晶体管的器件，使用的晶体管越多，也就意味着要占用更多的芯片面积
    
    随着技术的进步，后续出现了使用六个晶体管来存储一位数据的静态RAM存储器（简称SRAM），如下图所示：
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%207.png)
    
    也出现了使用1个电容加一个晶体管来存储一位数据的动态RAM存储器（简称DRAM），如下图所示
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%208.png)
    
    平常所说的“内存条”其实指的就是DRAM存储器，它在读取和写入数据时会更耗时
    
- 地址线条数越多，这会导致芯片的引脚数量变得更多
    
    为解决这个问题，一般是将RAM中存储的二进制位组织成行和列，然后将地址拆分为行地址和列地址。比方说下边是一个包含4行4列的RAM的示意图：
    
    一般是将RAM中存储的二进制位组织成行和列，比方说下边是一个包含4行4列的RAM的示意图
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%209.png)
    
    其中每一个小方格都代表若干个二进制位，我们可以分两次给出某个小方格对应数据的地址
    
    1. 先给出数据的行地址，这一步骤称为行激活
        
        ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2010.png)
        
        在发送行地址之后，要等待若干个时钟周期才能继续发送列地址（具体等待多少个时钟周期取决于RAM的型号以及我们所使用的时钟频率）
        
    2. 然后给出数据的列地址，如果是写入操作还需要给出待写入的数据，如下图所示：
        
        ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2011.png)
        
        如果接下来还需访问本行内的其他列，那么紧接着只发送列地址即可；如果接下来要访问别的行中的数据，那就得先发送该行地址将其激活，然后再给出列地址
        

图中最下边那一排金灿灿的条状金属片格外引人注目，它们就是内存条与外部设备通信的引脚，俗称金手指，如下图所示：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2012.png)

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2013.png)

访问（读或写）这种大容量RAM除了要分别发送行地址和列地址之外，还需要通过控制信号发送预充电、周期性刷新等命令，还需要考虑发送不同命令之间的时间延迟

CPU在与大容量RAM这种十分复杂的硬件进行通信时，与其CPU自己搞明白通信的每一个细节，不如直接找一个中介。CPU直接把要访问的地址和数据交给中介（按照以前直接和RAM通信的方式与中介进行沟通），中介再去处理和大容量RAM的具体沟通细节，沟通完成后再把结果交给CPU

可以把这个中介称作`RAM控制器`（RAM Controller），`RAM控制器`给CPU提供了非常友好的访问接口，让CPU专注于做自己的事情，而无需考虑与复杂RAM通信的各种细节

**CPU和RAM控制器的通信**

因为引入复杂的RAM后，`RAM控制器`读写RAM的过程可能需要多个时钟周期，在这个过程中有两个核心的问题需要解决：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2014.png)

1. RAM控制器需要知道CPU啥时候给它发送读/写请求，在接收到请求之后它才能进一步和实际的RAM进行沟通
2. CPU需要知道RAM控制器啥时候将结果准备好

为解决这两个问题，CPU和RAM控制器的通信方式就不能简单的和之前CPU与RAM直接沟通的方式一样了，我们需要引入了一些新信号, 先看一个超简单的RAM控制器需要在之前介绍的RAM的基础上需要增加哪些信号（RAM控制器的各个信号都以RC_开头）：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2015.png)

与之前的RAM相比，RAM控制器新增了这些信号：

- RC_RST_N_I：
    
    RAM控制器内部也维护了一个产生状态的`有限状态机`，在复位之后，该RAM控制器会处于空闲状态，等待CPU发送读/写请求
    
- RC_HELLO_I
    
    处在`空闲状态`的`RAM控制器`会在每个时钟信号上升沿都会检测 RC_HELLO_I 输入信号：
    
    - 当 RC_HELLO_I = 0时，意味着此时CPU并没有发送读/写请求，RAM控制器可继续保持空闲状态
    - 当 RC_HELLO_I = 1时，意味着此时CPU正在发送读/写请求，RAM控制器从空闲状态转换到别的状态去处理对应的读/写请求
- RC_ACK_O
    
    当RAM控制器处理完与RAM的复杂交互后，需要通知CPU，此时就将RC_ACK_O输出信号设置为逻辑1。这时CPU的一次读/写操作就算是做完了。然后在下一个时钟周期进入空闲状态，等待CPU给自己发送读/写请求
    

CPU也需要做相应的改变：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2016.png)

如图所示，CPU新增了2个信号：

- CPU_HELLO_O：
    
    每当CPU想从RAM中读取或写入数据时，就将CPU_HELLO_O设置为逻辑1，并且：
    
    - 当读取数据时，需要同时让CPU_WE_O=0、CPU_ADDR_O上给出待读取数据对应的地址
    - 当写入数据时，需要同时让CPU_WE_O=1、CPU_ADDR_O上给出待写入数据对应的地址以及CPU_DATA_O上给出待写入数据的内容
- CPU_ACK_I:
    
    在CPU向RAM控制器发出读/写请求时，需要等待RAM控制器的响应，具体就是在每个时钟信号上升沿都检测CPU_ACK_I输入信号
    
    - 当CPU_ACK_I=0时，说明CPU还需等待，不能进行下一步操作
    - 当CPU_ACK_I=1时，说明可以进行下一步操作

引入了RAM控制器后，整个电路的各个部分可以这样连接：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2017.png)

**CPU处理CPU_ACK_I输入信号**

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2018.png)

**状态生成器修改**

知道现在CPU拥有2个状态：`取指状态`和`执行状态`：

- 当CPU处于`取指状态`时，它正在等待RAM控制器给自己返回指令，那么：
    - 当CPU_ACK_I=0时，说明RAM控制器并未准备好指令，那么下一个时钟周期CPU还得继续保持为`取指状态`不变
    - 当CPU_ACK_I=1时，说明RAM控制器已经准备好了指令，那么下一个时钟周期可以转到`执行状态`
    
    也就是当Snow=0时：
    
    - 当CPU_ACK_I=0时，Snext=0
    - 当CPU_ACK_I=1时，Snext=1
- 当CPU处于`执行状态`时，那么
    - 如果正在执行不需要访问RAM的指令，诸如add_i，load_i等，那么下一个时钟周期上升沿到达后即可转到`取指状态`工作
    - 如果正在执行需要访问RAM的指令，诸如add_m，store等，那么得继续细分情况讨论：
        - 当CPU_ACK_I=0时，说明RAM控制器并未准备好数据，或者写入操作尚未完成，那么CPU还得继续保持为`执行状态`不变
        - 当CPU_ACK_I=1时，说明RAM控制器已经准备好数据，或者写入操作已经完成，那么CPU在下一个时钟周期进入`取指状态`
    
    很显然我们得在`执行状态`区分一下当前执行的指令需不需要访问RAM，我们可以引入一个名为`ACCESS_RAM_INS`的信号来标记当前执行的指令是否需要访问RAM，这个信号可以由`1号控制单元`生成
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2019.png)
    
    这样：
    
    - 当ACCESS_RAM_INS=0时，意味着正在执行不需要访问内存的指令，诸如add_i、load_i等
    - 当ACCESS_RAM_INS=1时，意味着正在执行需要访问内存的指令，诸如add_m、store等
    
    引入了ACCESS_RAM_INS信号之后，我们再回过头看当Snow=1时
    
    - 如果ACCESS_RAM_INS=0，Snext=0
    - 如果ACCESS_RAM_INS=1，分情况讨论：
        - 如果CPU_ACK_I=0，Snext=1
        - 如果CPU_ACK_I=1，Snext=0

这样我们就可以写出CPU的当前状态Snow以及下一个状态next之间的真值表：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2020.png)

根据这个真值表，我们可以很容易的制作出新的`状态生成器`（从真值表中找出所有Snext为1的行，然后根据这些行的输入，分别制作一个只在该输入情况下输出才为1的设备，最后将这些设备的输出作为一个或门的输入即可）

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2021.png)

还是把这个新的`状态生成器`装在黑盒子里：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2022.png)

把新制作的`状态控制器`和`1号控制单元`放到完整的`控制单元`中就是这样

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2023.png)

**其他控制信号的处理**

- 取指状态的控制信号修改
    
    在引入了RAM控制器后，当CPU处在`取指状态`时，如果RAM控制器尚未返回指令，那在下一个时钟周期上升沿到达后不应该更新任何一个存储设备，也就是电路中的各种WE信号都应为逻辑0。幸运的是，在上图对应的`控制单元`中，当CPU处于`取指状态`时，只有IR_WE信号为逻辑1，其余WE信号均为逻辑0。接下来我们只需要：
    
    - 当STATE=0、CPU_ACK_I=0时，令IR_WE=0
    - 在其他情况下让_IR_WE信号保持为原控制单元生成的信号不变
    
    完成这个功能很简单，引入一个`2-1选择器`即可
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2024.png)
    
    或非门具有“只有当两个输入都为0时，输出才为1”的特性，所以只有当STATE=0、CPU_ACK_I=0时，上图中`2-1选择器`的控制信号才为逻辑1，生成的新IR_WE才为逻辑0。在其他输入的情况下，新的IR_WE信号和之前的IR_WE信号保持一致
    
- 执行状态的控制信号修改 当CPU处在`执行状态`时，如果执行的是需要访问RAM的指令（ACCESS_RAM_INS=1），那下一个时钟周期上升沿除RAM_WE信号之外的所有WE信号都应为逻辑0（稍后解释RAM_WE信号为何可以除外）。在之前制作的`控制单元`中，在`执行状态`
，会将PC_WE、ACC_WE、ZF_WE设置为逻辑1，IR_WE设置为逻辑0。所以我们需要
    - 当STATE=1、ACCESS_RAM_INS=1、CPU_ACK_I=0时，令PC_WE=0、ACC_WE=0、ZF_WE=0
    - 在其他情况下让PC_WE、ACC_WE、ZF_WE信号保持为原控制单元生成的信号不变
    
    完成这个功能很简单，引入一个`2-1选择器`即可：
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2025.png)
    
    为啥我们不需要重新生成RAM_WE信号呢？因为RAM_WE信号其实是给RAM控制器的输入信号RC_RAM_WE，那么
    
    - 当CPU执行读取RAM的指令时，比方说add_m，RAM_WE肯定为逻辑0
    - 当CPU执行写RAM的指令，也就是store指令时，在RAM控制器将数据写入RAM的整个过程中，它的RC_RAM_WE信号都保持为逻辑1也没什么问题

那我们可以把修改后的IR_WE、PC_WE、ACC_WE、ZF_WE信号生成过程封装在一个黑盒子里，如下图所示

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2026.png)

把上边的黑盒子放在完整的`控制单元`中：

![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2027.png)

**CPU生成CPU_HELLO_O信号**

现在还剩最后一个问题就是如何生成CPU_HELLO_O信号了。我们需要先分析一下什么时候CPU需要访问RAM：

- 当CPU处于取指状态时，需要访问RAM
    
    也就是当STATE=0时，令CPU_HELLO_O=1
    
- 当CPU处于执行状态，分两种情况讨论：
    - 当执行的是需要访问RAM的指令时，也就是当STATE=1、ACCESS_RAM_INS=1时，令CPU_HELLO_O=1
    - 当执行的是不需要访问RAM的指令时，也就是当STATE=1、ACCESS_RAM_INS=0时，令CPU_HELLO_O=0
    
    ![Untitled](%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%20RAM%20%E7%9A%84%E7%9F%9B%E7%9B%BE%20d0de522c489840b0843fb7c165044f59/Untitled%2028.png)
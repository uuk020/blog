# 存储器

在引入寄存器之后，我们将用于累加的设备改造成了这个样子：

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled.png)

在这个设备中，每次CLK时钟信号上升沿到达后，就可以在输入设备上生成下一个加数对应的信号，可是这里边有一个问题，只要我们错误的输入了一个加数（比方说把第4个加数20错误的当作了21），那么前边输入的3个加数都就无效了，就得把复位信号RST_N设置为逻辑0，然后让整个过程从头再来, 若这个设备是累加100个数, 1000个数, 工程量剧增.

这问题还不简单么，提前通过输入设备把这些需要累加的数都分别存到一个寄存器上，就像这样

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%201.png)

现在我们有4个加数，就需要使用4个寄存器来存储它们对应的信号，我们为每个寄存器编一个号来对应一个加数（我们从0开始编号，0号寄存器对应一个第1个加数，1号寄存器对应第2个加数，以此类推）

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%202.png)

那么当我们再使用累加设备时，就可以不再使用输入设备临时生成每个加数对应的信号，而是直接使用该加数对应的寄存器了

这个方案听着好像挺靠谱，可是如果我们要累加100个数的话，那就需要额外的100个寄存器，这些寄存器光编号就得好一阵子，每次找的时候也贼麻烦。我们其实完全可以把这些寄存器套在一个黑盒子里，然后向使用者提供用户友好的操作方式就好了。用户友好的操作方式指的是可以很方便的找到某个寄存器进行读写，而不是从散落到一地的寄存器中去找某个寄存器

### **多路选择器的使用**

如何从多组输入信号中挑选一组作为输出信号呢？很显然多路选择器就可以解决这个需求。比方说我们现在有4个寄存器，我们想读取其中某个寄存器中存储的数据，只需要在这4个寄存器后边加一个`4-1选择器`即可

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%203.png)

- 当`S₁=0, S₀=0`，也就是当控制信号为`00`（也就是十进制的`0`）时，`4-1复用器`的输出`Dout`就是0号寄存器中存储的数据
- 当`S₁=0, S₀=1`，也就是当控制信号为`01`（也就是十进制的`1`）时，`4-1复用器`的输出`Dout`就是1号寄存器中存储的数据
- 当`S₁=1, S₀=0`，也就是当控制信号为`10`（也就是十进制的`2`）时，`4-1复用器`的输出`Dout`就是2号寄存器中存储的数据
- 当`S₁=1, S₀=1`，也就是当控制信号为`11`（也就是十进制的`3`）时，`4-1复用器`的输出`Dout`就是3号寄存器中存储的数据。

简而言之就是两个控制信号组合起来对应的数字是几，`4-1选择器`的输出就是几号寄存器中存储的数据！就像我们通过地址可以定位到某个地方一样，我们通过`4-1选择器`的控制信号就可以定位到一个寄存器，所以选择器的控制信号也被称为`地址信号`

地址信号的组合对应的数字也可以被称之为某个寄存器的`地址`，也就是说`00`（十进制`0`）、`0`（十进制`1`）、`10`（十进制`2`）、`11`（十进制`3`）这些都分别算是一个地址。

### **译码器的使用**

好了，到现在为止读取操作是比较友好了，可是如果我们想改某个寄存器中存储的数据咋办呢？先试试直接把数据输入信号连接到各个寄存器的输入端会发生什么：

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%204.png)

如图所示，如果我们直接把数据输入信号连接到了各个寄存器的输入端，那么在我们把CLK时钟信号从逻辑0调整到逻辑1后，所有寄存器中存储的值都会发生改变！这显然不能符合我们的需求

带有写使能信号的寄存器，把上图中使用到的普通寄存器替换成带使能信号的寄存器即可解决这个问题

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%205.png)

如图所示，如果我们想修改`0号寄存器`中的数据，只需让WE0=1，让WE1=0、WE2=0、WE3=0，然后在CLK信号的上升沿到来后，0号寄存器中存储的数据就变成了数据输入Din
代表的数据。类似，如果我们想修改其他寄存器的值，只需将该寄存器对应的WE信号设置为逻辑1，将其余寄存器的WE信号设置为逻辑0即可。

可是这样也有一个问题，就是如果有100个寄存器，那我们需要手动设置100个表示WE信号，这个就太不划算了。其实在每次CLK信号上升沿到达时，我们只需要修改一个寄存器中的数据即可。如果我们想修改多个寄存器中的数据，那就分多次分别修改就好了。那么我们在修改某个寄存器中的数据时，需要让该寄存器的WE信号为逻辑1，让其余寄存器的信号皆为逻辑0

目前我们只使用了4个`8位寄存器`，那么

- 如果我们想修改0号寄存器中的数据，需要让WE0=1，让其余的寄存器的WE信号均为逻辑0。
- 如果我们想修改1号寄存器中的数据，需要让WE1=1，让其余的寄存器的WE信号均为逻辑0。
- 如果我们想修改2号寄存器中的数据，需要让WE2=1，让其余的寄存器的WE信号均为逻辑0。
- 如果我们想修改3号寄存器中的数据，需要让WE3=1，让其余的寄存器的WE信号均为逻辑0。

一根信号线可以表示2种信息，两根信号线可以表示4种信息，理论上我们只需要2根信号线就可以表示出上述4种情况。比方说我们使用S₃、S₂这两个信号表示上述4种情况

- 我们可以做出一个只在S₃=0、S₂=0时，WE0=1的设备，如下图所示：
    
    ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%206.png)
    
- 我们可以做出一个只在S₃=0、S₂=1时，WE1=1的设备，如下图所示：
    
    ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%207.png)
    
- 我们可以做出一个只在S₃=1、S₂=0时，WE2=1的设备，如下图所示:
    
    ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%208.png)
    
- 我们可以做出一个只在S₃=1、S₂=1时，WE3=1的设备（其实就是个与门），如下图所示
    
    ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%209.png)
    

把上述4个设备连接起来如下图所示：

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2010.png)

那么对于这个设备来说：

- 当S₃=0、S₂=0时，只有WE0=1，让其余WE信号均为逻辑0。
- 当S₃=0、S₂=1时，只有WE1=1，让其余WE信号均为逻辑0。
- 当S₃=1、S₂=0时，只有WE2=1，让其余WE信号均为逻辑0。
- 当S₃=1、S₂=1时，只有WE3=1，让其余WE信号均为逻辑0。

当然也可以简化一下（下图比上图省了2个非门，不过功能是一样的）：

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2011.png)

此设备有一个专业的名称：`2线-4线译码器`，我们后边会将其简称为`2-4译码器`。老规矩，电路图太复杂，我们将其封装到一个盒子里

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2012.png)

将`2-4译码器`应用在那个包含多个寄存器的电路中，我们就可以仅可以通过生成2根信号线上的信号来生成各个寄存器的WE信号了

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2013.png)

这样的话，如果我们想修改第0号寄存器的数据，只需要让S₃=0、S₂=0（而不是像原来那样设置WE0、WE1、WE2、WE3四个信号），然后在CLK信号上升沿到来后，数据输入Din
代表的数据就写到了第0号寄存器中

在很多场景下，即使CLK时钟上升沿到来，我们也不想更新某个寄存器中的数据，所以有必要引入一个全局的WE（Write Enable）信号，来控制什么时候允许修改寄存器中的数据，改进之后

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2014.png)

因为与门有“当一个输入信号为逻辑0时，最终的输出肯定为逻辑0”的特性，所以当全局WE=0时，各个寄存器接收到的WE信号都是逻辑0，也就意味着各个寄存器都不允许修改数据了

到目前为止，我们在`4-1选择器`上添加了两个信号S₁和S₀，这两个信号用于选择读出哪个寄存器的数据；我们在`2-4译码器`上添加了也2个信号S₃和S₂，这两个信号用于控制选择需要修改哪个寄存器中的数据。如果我们只用来读取某个寄存器的数据，那么只指定S₁和S₀即可，如果我们只用来修改某个寄存器的数据，那么只指定S₃和S₂即可。如果我们不同时读取和写入的话，其实让S₁和S₀与S₃和S₂合并为一组信号也可以（也就是让S₃=S₁、S₂=S₀）

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2015.png)

一般情况下我们会将地址信号命名为`A`（A代表Address），所以RAM的示意图可以被画成

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2016.png)

### **制作容量更大的存储器**

我们上边制作了一个有4个地址，每个地址可以访问到8个二进制位的RAM，这个容量还是太小了，我们可以从两个方向上扩展容量

- 扩展每个地址可以访问到的二进制位个数
在地址个数不变的情况下，我们也可以通过扩展存储数据的寄存器位数来达到扩展容量的目的，比方说把之前用的8位寄存器替换成16位寄存器，就可以制作成容量为`4×16`的RAM，替换成32位寄存器，就可以制作成容量为`4×32`的RAM，还可以制作`4×64`、`4×128`等等容量的RAM
- 扩展地址个数
我们可以使用3-8译码器，8-1复用器来制作出容量为`8×8`的RAM，可以使用4-16译码器，16-1复用器来制作出容量为`16×8`的RAM，还可以制作`32×8`、`64×8`等等容量的RAM。

当然，我们也可以不改变已有RAM的内部结构，而采用将多个现成的RAM组合起来的方式去扩展RAM容量。比方说我们现在有两个容量为`4×8`的RAM，分别称为1号RAM和2号RAM，那么我们也可以从两个方向上扩展

- 扩展每个地址可以访问到的二进制位个数，我们可以用下边的方式将两个RAM连接起来
    
    ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2017.png)
    
    如图所示，两个`RAM`的地址信号、时钟信号、写使能信号是相同的，但是可以一次读取/写入16个二进制位的数据，所以1号RAM和2号RAM按照上图组合起来后变为了一个容量为`4×16`的RAM
    
- 扩展地址个数，我们可以用下边的方式将1号RAM和2号RAM组合起来
    
    ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2018.png)
    
    如图所示，我们新引进了一个`2-1复用器`和一个控制信号A₂，那么
    
    - 当A₂=0时，`2-1复用器`的输出为`1号RAM`的数据输出，而且写使能信号WE能顺利的传播到`1号RAM`，而此时`2号RAM`接收的写使能信号WE始终为逻辑0。效果等价于下边这个图
        
        ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2019.png)
        
    - 当A₂=1时，`2-1复用器`的输出为`2号RAM`的数据输出，而且写使能信号WE能顺利的传播到`2号RAM`，而此时`1号RAM`接收的写使能信号WE始终为逻辑0。效果等价于下边这个图
        
        ![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2020.png)
        
        简而言之就是`A₂`决定了具体的读写操作到底是作用在哪个RAM上，当A₂=0时，1号RAM起作用；当A₂=1时，2号RAM起作用。这样子从效果上来说我们总共可以读写8个8位二进制数，换个角度考虑的话，我们也可以将A₂也当作一个地址信号，那么现在的地址信号就有3个，上图中1号RAM和2号RAM的组合整体上就代表一个更大号的RAM，这个更大号的RAM的容量是`8×8`
        

### **RAM的应用**

在掌握了RAM的使用方式后，我们可以将所有的加数都输入到RAM中去。由于狗哥提的累加问题只涉及4个加数，各个加数以及最后的加和结果都可以使用一个8位二进制数表示，所以我们这里采用容量为`4×8`的RAM去存储这4个加数就足够了

> 向RAM中写入数据的过程就是先设置地址信号、数据输入信号，之后再将WE信号设置为逻辑1，最后再将CLK信号从逻辑0调整到逻辑1，即可完成一次数据写入。将4个加数写入RAM的具体过程我们就不赘述了
> 

将各个加数都写入RAM后，RAM的地址与数据的对应关系就如下图所示：

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2021.png)

然后用这个填充好数据的RAM去替换之前累加设备中的`8位输入设备`（在将数据写入RAM后，我们便用不到RAM的CLK和WE信号，故将其一直设置为逻辑0），如下图所示

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2022.png)

既然数据RAM的CLK信号和WE信号始终保持逻辑0，那我们在画图的时候就直接用数字`0`来替代那个`1位输入设备`对应的方框了。另外，目前ALU使用来进行加法运算的，所以ALU的控制信号需要始终保持为`00`，也就是十进制的0，所以我们也用数字`0`来替代生成ALU控制信号的那个`2位输入设备`对应的方框，简化后的电路图如下所示

![Untitled](%E5%AD%98%E5%82%A8%E5%99%A8%2058f188f4915c46aba15ae7568f949faf/Untitled%2023.png)

然后将RST_N信号设置成逻辑0后再设置成逻辑1，从而让用于存储累加结果的寄存器的输出清零，之后再将CLK信号设置为逻辑0。因为各个加数都已经事先存储到RAM中去了，所以我们接下来只需要手动生成RAM的地址信号，来让RAM输出不同的加数，从而完成累加操作。

- 通过调节`2位输入设备`，先让RAM的地址为`00`，那么RAM的输出就是74，此时ALU的输出就是74+0=74。再将CLK信号从逻辑0调整为逻辑1，ALU的输出被写入寄存器，之后再将CLK信号从逻辑1调整为逻辑0
- 通过调节`2位输入设备`，再让RAM的地址为`01`，那么RAM的输出就是29，此时ALU的输出就是29+74=103。再将CLK信号从逻辑0调整为逻辑1，ALU的输出被写入寄存器，之后再将CLK信号从逻辑1调整为逻辑0
- 通过调节`2位输入设备`，再让RAM的地址为`10`，那么RAM的输出就是32，此时ALU的输出就是32+103=135。再将CLK信号从逻辑0调整为逻辑1，ALU的输出被写入寄存器，之后再将CLK信号从逻辑1调整为逻辑0
- 通过调节`2位输入设备`，再让RAM的地址为`11`，那么RAM的输出就是20，此时ALU的输出就是20+135=155
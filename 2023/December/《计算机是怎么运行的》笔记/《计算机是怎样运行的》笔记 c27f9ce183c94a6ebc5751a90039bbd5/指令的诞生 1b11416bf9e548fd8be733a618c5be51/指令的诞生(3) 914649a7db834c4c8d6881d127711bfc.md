# 指令的诞生(3)

只要我们在`指令RAM`和`数据RAM`中输入对应的指令和数据，我们设计的那个电路就可以自动地将结果算出来，并将结果写入`数据RAM`的指定地址处

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled.png)

计算下边这个式子的结果：

```
5 + 3 + 11 + 8 + 3 + 22 + 8 + 7 + 34
```

能不能只算`数据RAM`中地址为0、1、8对应数据的加和，而忽略其他地址对应的数据呢

重新把`指令RAM`和`数据RAM`中的数据填充一遍，填成下边这样子不就好了

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%201.png)

当时过于麻烦, 每次都重新填好多处的数据, 其实是想在执行完地址为1的指令之后，跳过地址为2、3、4、5、6、7的这几条指令，直接执行地址为8的指令

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%202.png)

回顾一下当前设备是如何执行的：程序计数器的输出表示当前`指令RAM`和`数据RAM`的地址，每当时钟信号上升沿到达后，程序计数器的值就会递增1，所以在下一时钟周期去执行下一条指令。如果想直接执行某条指令的话，我们直接将程序计数器的值设置为该指令对应的地址不就好了么

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%203.png)

如图所示，我们在程序计数器前放置了一个2-1选择器，我们把这个2-1选择器的控制信号称为`PC_SEL`，那么：

- 当PC_SEL=0时，程序计数器的输入就等于当前程序计数器的输出加1，我们可以简称为`PC+1`。这也是之前我们一直在用的逻辑，即下一时钟周期执行的指令地址比当前正在执行的指令地址大1
- 当PC_SEL=1时，程序计数器的输入就是`数据RAM`的输出（当前数据RAM的输出共有8位，这里选取低6位作为程序计数器的输入）。

现在指令输出的8个二进制位中只使用了6个，我们可以再找一个二进制位，比方说编号为6的二进制位表示这个PC_SEL信号，如下图所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%204.png)

然后我们可以新引入一个指令`jmp`，当执行该指令时，让PC_SEL=1，在执行其他指令时，让PC_SEL=0。这样当执行到jmp指令时，就可以跳转到指定的地址去执行指令

这样的话，现有的指令以及其对应的二进制形式就如下表所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%205.png)

只需要将原先`指令RAM`地址为2处的指令修改为`jmp`，将原先`数据RAM`地址为2处的数据修改为`8`（也就是我们需要跳转到的地址），`指令RAM`和`数据RAM`的数据填充情况就如下所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%206.png)

那么，在第2周期时，`指令RAM`输出jmp指令，PC_SEL信号变为逻辑1，程序计数器的输入为`数据RAM`
的输出：8。那么在第3周期时钟信号上升沿到来后，程序计数器的输出就变为了8，也就意味着第3周期在执行地址为8处的指令

### **条件跳转指令**

jmp指令属于`无条件跳转指令`，也就是说只要执行到jmp指令，在下一时钟周期就会跳转到jmp指令指定的地址去执行，不需要任何条件。可更多时候我们需要的是`有条件跳转指令`，简称`条件跳转指令`。也就是在符合某个条件的时候才会跳转到指定的地址去执行，否则不跳转

这里所说的“条件”是什么呢？先看几个现实世界中的两个根据不同条件做不同操作的场景：

- 如果你的某科成绩大于60分，那么这科成绩才算及格，否则不及格
- 如果你的年均纯收入不小于4000，那你就脱贫了，否则你就是贫困人口

生活中最常出现的“条件”就是比较两个数的大小，根据比较结果来做不同的操作。再回到我们这里，在执行指令跳转操作前也可以判断一下两个数的比较结果是否符合预期，如果符合再跳转，否则不跳转。假设我们有两个数a和b，那么可以有多种比较条件

- 条件一： 如果a等于b，就跳转，否则不跳转
- 条件二： 如果a不等于b，就跳转，否则不跳转
- 条件三： 如果a小于b，就跳转，否则不跳转
- 条件四： 如果a小于或等于b，就跳转，否则不跳转
- 条件五： 如果a大于b，就跳转，否则不跳转
- 条件六： 如果a大于或等于b，就跳转，否则不跳转

可以换一种思路去理解比较两个数大小的过程，比较a和b的大小其实可以相当于去计算a-b的差，那么：

- 如果差为0，意味着a和b相等
- 如果差为正数，意味着a大于b
- 如果差为负数，意味着a小于b

这就意味着如果我们想根据某两个数的比较结果去作为是否进行跳转的依据的话，只需要先将这两个数做减法运算，然后再判断差是0、正数或者负数就好了。不过出于简化的目的考虑，我们接下来只准备实现在两个数相等的时候才进行跳转的指令。那么在ALU做运算的时候，就需要知道运算结果是否为0，那么可以这样改造一下ALU

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%207.png)

如图所示，我们引入了一个比较器，比较器的一个输入恒为0，另一个输入为ALU的运算结果，我们就可以通过比较器的输出`ZF`(Zero Flag的缩写）来判断运算结果是否为0：

- 如果ZF=0，那意味着运算结果不为0
- 如果ZF=1，那意味着运算结果为0

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%208.png)

接下来就可以根据ALU的ZF输出来判断到底是不是要执行跳转了。我们可以引入一个名为`je`（jump equal的简称）的指令，当执行这个指令时，如果上一次算术/逻辑运算的结果为0，那么就跳转到指定地址执行指令，否则就不跳转

之前我们将指令编号为6的二进制位作为程序计数器前的2-1选择器的控制信号PC_SEL，当执行jmp指令时，PC_SEL信号为逻辑1，从而可以让程序计数器的输入变为指定的地址，那么在下一时钟周期的时钟信号上升沿到来后，程序计数器输出我们指定的地址，从而让机器执行指定地址处的指令

现在引入了je指令，这个指令也可能会修改PC_SEL信号，也就是说PC_SEL信号由jmp指令和je指令共同决定，所以我们不能单纯的将指令编号为6的二进制位作为PC_SEL信号了。那么我们可以新定义两个信号JMP_NO_COND和JMP_COND信号，并且让：

- 指令中编号为6的二进制位代表JMP_NO_COND信号（COND是CONDITION的缩写）
- 指令中编号为7的二进制位代表JMP_COND信号

那么指令的各个二进制位表示的含义就变成了下边这样

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%209.png)

这样的话，现有的指令以及其对应的二进制形式就如下表所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2010.png)

也就是说在执行jmp指令时，JMP_NO_COND=1、JMP_COND=0。 在执行je指令时，JMP_NO_COND=0、JMP_COND=1

那么：

- 当执行jmp指令时，JMP_NO_COND=1，PC_SEL信号肯定需要被设置为逻辑1
- 当执行je指令时，JMP_COND=1，只有当ZF=1时，PC_SEL才被设置为逻辑1

很显然下边的电路图满足上述关系：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2011.png)

准备工作都做完了，接下来是时候把上边这些东西应用到整体的电路图中：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2012.png)

上图中有一点需要注意，我们先得在一个时钟周期内执行sub指令来计算两个数的差，在下一时钟周期才可以执行je指令来根据减法的结果来决定是不是要跳转到指定地址。

那么在执行sub指令的时钟周期中，ALU输出的ZF信号需要在下一个时钟周期中才有用，所以我们引入了一个称为ZF寄存器的器件来存储执行sub指令时产生的ZF信号

现在如果我们向`指令RAM`和`数据RAM`中填入如下图所示的数据

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2013.png)

由于3-5≠0（地址为1处的指令就是计算3-5的值），所以地址为2的je指令执行完后，并不会跳转到地址为8的指令，而是继续执行地址为3的指令。如果我们把`数据RAM`
中地址为1处的数据换成5，如下图所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2014.png)

由于5-5=0，所以地址为2的je指令执行完后，会跳转到地址为8的指令。

> 在我们目前的设计中，在执行je指令时，只是看上一次ALU的运算结果是不是0，而不管ALU上一次做的什么运算，所以目前发生跳转的“条件”就不局限于比较两个数是否相等了，不管是加法运算、减法运算、按位与运算还是按位或运算，只要它们的运算结果为0，那么接着执行je指令时都会发生跳转。
> 

### 优化指令

在前边的表述里可能也感受到了：指令的本质其实就是控制信号：

- 编号为0和1的二进制位可以让ALU进行不同类型的运算
- 编号为2的二进制位可以控制电路中的各个寄存器和`数据RAM`能否正常接收到时钟信号
- 编号为3的二进制位就是`数据RAM`的WE信号
- 编号为4的二进制位就是控制累加器的WE信号
- 编号为5的二进制位就是靠近ALU的2-1选择器的控制信号
- 编号为6和7的二进制位决定着靠近程序计数器的2-1选择器的控制信号

随着电路中器件的增多，所需的控制信号也逐渐增多。每新增一个控制信号，表示指令的二进制位个数也相应的增加一个或多个（目前，靠近程序计数器的2-1选择器的控制信号对应指令中的两个二进制位，其余控制信号都对应一个二进制位）。

我们目前设计的指令还是比较少的，所以以这种方式增加指令感觉也没啥问题，不过当我们指令设计的特别多（现代计算机的指令可能多达几百上千个）时，如果继续每增加一个控制信号就要多使用一个或多个二进制位来表示它的话，那每一条指令可能要成百上千个二进制位才能表示，这是我们承受不起的代价，所以有必要给指令瘦个身。

知道1个二进制位可以表示2个数字，2个二进制位可以表示$2^2$=4个数字，n个二进制位就可以表示$2^n$
个数字。我们现在一共设计了9个指令，理论上使用4个二进制位就可以表示它们，假设我们把每一个指令和一个4位二进制数按照下边的方式映射起来

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2015.png)

这样的话指令的二进制形式就和实际需要的控制信号没有直接联系了, 可以人为地给它们创造间接联系

这些控制信号是由指令和ZF寄存器的输出共同决定的，我们现在使用4个二进制位表示指令，那这4个二进制位和ZF寄存器的输出可以充当输入信号（我们把它们分别称为A、B、C、D和ZF），ALU的控制信号S₁和S₀、`数据RAM`的写使能信号（我们可以将其称为RAM_WE）、累加器的写使能信号（我们可以将其称为ACC_WE）、靠近ALU的2-1选择器的控制信号（我们可以将其称为ALU_A_SEL）、靠近程序计数器的2-1选择器的控制信号PC_SEL、程序停止信号HALT都充当输出信号，这些信号组成的真值表如下表所示

| 指令 | A(输入) | B(输入) | C(输入) | D(输入) | ZF(输入) | S₁（输出） | S₀（输出） | HALT（输出） | RAM_WE（输出） | ACC_WE（输出） | ALU_A_SEL（输出） | PC_SEL（输出） |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| add | 0 | 0 | 0 | 0 | X | 0 | 0 | 1 | 0 | 1 | 0 | 0 |
| sub | 0 | 0 | 0 | 1 | X | 0 | 1 | 1 | 0 | 1 | 0 | 0 |
| and | 0 | 0 | 1 | 0 | X | 1 | 0 | 1 | 0 | 1 | 0 | 0 |
| or | 0 | 0 | 1 | 1 | X | 1 | 1 | 1 | 0 | 1 | 0 | 0 |
| halt | 0 | 1 | 0 | 0 | X | X | X | 0 | X | X | X | X |
| store | 0 | 1 | 0 | 1 | X | X | X | 1 | 1 | 0 | X | 0 |
| load | 0 | 1 | 1 | 0 | X | 0 | 0 | 1 | 0 | 1 | 1 | 0 |
| jmp | 0 | 1 | 1 | 1 | X | X | X | 1 | 0 | 0 | X | 1 |
| je | 1 | 0 | 0 | 0 | 1 | X | X | 1 | 0 | 0 | X | 1 |
| je | 1 | 0 | 0 | 0 | 0 | X | X | 1 | 0 | 0 | X | 0 |

> je指令在不同的ZF信号的情况下会生成不同的控制信号（这里的控制信号指的是PC_SEL），所以je指令在真值表里占了2行。而在执行其他指令时是不关心ZF信号是什么的，所以ZF信号用X表示，其他指令在真值表中只占一行
> 

如果我们先不看其他信号，单单把输出信号S₁拿出来，那么真值表就是这样的, 看上图.

这不就是一个五输入逻辑门的真值表么！我们可以采用最笨的方式把这个五输入逻辑门的电路图画出来

- 从真值表中找出所有输出信号为逻辑1的行
    
    很显然，在执行and和or指令时，输出信号S₁才为逻辑1，也就是当输入为`0010X`和`0011X`的时候，输出信号S₁为逻辑1
    
    在输入为`0010X`和`0011X`时，ZF信号为X，意味着它取逻辑0和逻辑1均可，也就意味着输出信号S₁和输入信号ZF没有关系，所以我们可以忽略输入信号ZF，五输入逻辑门就可以退化为四输入逻辑门
    
- 先制作一个只有在输入为A=0、B=0、C=1、D=0的情况下输出才为逻辑1的设备，我们称之为`设备1`
    
    ![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2016.png)
    
- 再制作一个只有在输入为A=0、B=0、C=1、D=1的情况下输出才为逻辑1的设备，我们称之为`设备2`
    
    ![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2017.png)
    
- 最后将上边两个设备的输出信号作为一个或门的输出信号，那么只要这两个设备中有一个输出信号为逻辑1，整体上的输出信号就为逻辑1，如图所示
    
    ![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2018.png)
    

这样子的话，这个生成S₁信号的四输入逻辑门就做好了

类似的，我们也可以通过制作别的多输入逻辑门来产生S₀、HALT、RAM_WE、ACC_WE、ALU_A_SEL、PC_SEL这些输出信号，使出封装大法，把生成这些信号的逻辑都放在一个黑盒子里，只露出输入信号线和输出信号线，其中的A、B、C、D其实是指令，我们把指令信号简称为INS（INSTRUCTION的前缀）信号，那么上图就可以被画成（目前一条指令有8个二进制位，我们只使用低4位就好了）, 就像这样：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2019.png)

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2020.png)

之前在计算第一个表达式`74 + 29 - 32 - 20`的值时，`指令RAM`和`数据RAM`中的数据分布情况如下图所示

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2021.png)

如图所示，有的指令需要读取`数据RAM`中的数据，比方说`load`、`add`、`sub`等；有的指令需要向`数据RAM`中写入数据，比方说`store`.

某个指令在`指令RAM`中的地址是什么，那么它需要访问（访问既可以是读取，也可以是写入）的数据在`数据RAM`中的地址也必须是什么。对于我们日常使用来说，这样子的规定不是不行，但是太僵化，也导致了我们不能重复利用`数据RAM`中的空间

可否让指令所在`指令RAM`中的地址，与该指令所需访问的数据在`数据RAM`中的地址不必须一致呢？比方说在`指令RAM`的地址为`0`处存储的指令为`load`，那么在执行该指令时，可以指定将`数据RAM`中任意地址处存储的数据加载到累加器，而不一定是地址为`0`处的数据

这样的话，我们就必须指定某个指令需要访问`数据RAM`中哪个地址对应的数据，所以需要将一条指令拆分成两个部分，我们可以分别把它们叫做`操作码`和`操作数`，就像这样：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2022.png)

`操作码`指的就是我们之前所描述的指令，它代表着这条指令将要执行什么操作，比方说操作码是`add`的话，意味要进行加法操作，如果操作码是`store`的话，意味着将要进行将数据从累加器中写入数据RAM的操作。

`操作数`指的就是该指令将要访问`数据RAM`中的哪个地址处的数据

这样为了计算表达式`74 + 29 - 32 - 20`的值，`指令RAM`和`数据RAM`中的数据分布情况可以是这样

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2023.png)

和不区分操作码和操作数的时候完成的功能一样～ 其实如果我们改变一下某个操作码对应的操作数，那么事情就变得有意思了起来：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2024.png)

- `load 3`表示将`数据RAM`中地址为3处的数据加载到累加器；
- `add 0`表示将累加器中的数据与`数据RAM`中地址为0处的数据相加后再保存到累加器；
- `sub 1`表示将累加器中的数据与`数据RAM`中地址为1处的数据相减后再保存到累加器；
- `sub 2`表示将累加器中的数据与`数据RAM`中地址为2处的数据相减后再保存到累加器；
- `store 0`表示将累加器中的数据保存到`数据RAM`中地址为0的地方（也就是将`数据RAM`中原先地址为0的数据给覆盖掉）。

也就是说这个过程其实计算的是`20 + 74 - 29 - 32`的值（而不是`74 + 29 - 32 - 20`的值了），并将最终的计算结果存放到`数据RAM`中地址为0的地方

在我们目前的设计中，一个操作码需要4个二进制位表示，一个操作数（也就是RAM的一个地址）需要6个二进制位表示，也就是一条指令总共需要10个二进制位表示。不过我们目前使用的`指令RAM`
的容量是`64×8`，也就是说指令RAM的输出是一个8位二进制数，为了方便起见，我们将其扩充为容量为`64×16`的`指令RAM`，就像这样：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2025.png)

如图所示，`指令RAM`的输出就变为了一个16位二进制数。我们可以人为的规定前8个二进制位用于表示操作码（目前实际上只使用其中的4个二进制位），后8个二进制位用于表示操作数（目前实际上只使用其中的6个二进制位），如图所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2026.png)

我们规划使用编号为8～15这8个二进制位作为操作码，不过目前的指令较少，实际只使用了编号为8～11这4个二进制位表示操作码；我们规划使用编号为0～7这8个二进制位作为操作数，不过目前最多支持64个地址，所以实际只使用编号为0～5这6个二进制位作为操作数

现在一条指令分成了`操作码`和`操作数`两部分，我们就可以这样改造电路图了：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2027.png)

与之前的电路图相比，我们做了如下修改：

- `数据RAM`不再接收程序计数器的输出作为地址信号，而是将`指令RAM`输出的编号为0～5的二进制位（也就是指令的操作数）作为地址信号。
- 控制单元接收`指令RAM`输出的编号为8～11的二进制位（也就是指令的操作码）作为输入。

### 立即数

上边介绍的`操作数`指的是`数据RAM`的地址，也就是说在执行指令过程中，需要通过`操作数`
所代表的地址到`数据RAM`中获取需要参与运算的数据，这是一个间接获取数据的过程。如果我们乐意的话，也可以在编写指令的时候直接将需要参与运算的数据作为`操作数`，这样的操作数也被称作`立即数`

当然这么描述可能不太直观，还是来举个例子吧。我们刚才计算表达式`20 + 74 - 29 - 32`
的值时，`指令RAM`和`数据RAM`中的数据分布如下图所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2028.png)

指令`load 3`、`add 0`、`sub 1`、`sub 2`、`store 0`中的`3`、`0`、`1`、`2`、`0`指的都是`数据RAM`
中的地址，如果我们把这些间接定位数据的地址换成要直接操作的数据，就像是这样：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2029.png)

如图所示：

- `load 20`就表示直接把数据`20`加载到累加器；
- `add 74`就表示将累加器中的数据与74直接相加后再保存到累加器；
- `sub 29`就表示将累加器中的数据与29直接相减后再保存到累加器;
- `sub 32`就表示将累加器中的数据与32直接相减后再保存到累加器。

不过`store 0`表示的含义仍然不变，就是将累加器中的数据保存到`数据RAM`中地址为0的地方。这样`20`、`74`、`29`、`32`就代表立即数

大家可以看到，引入立即数的好处就是指令看起来更加直观，并且我们不再需要将数据先输入到`数据RAM`，然后再到`指令RAM`的操作数中填入这些数据所对应的地址。不过这里边儿有一个巨大的问题，我们怎么知道一条指令中的操作数是一个地址还是一个立即数呢，比方说我们怎么知道`load 20`
中的`20`是一个立即数还是一个地址呢？我们不知道！所以有必要将操作数为RAM地址的指令和操作数为立即数的指令区别开来，如下表所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2030.png)

可以看到，如果我们在add、sub、and、or、load这些运算或者加载指令后边添加了`_m`
后缀，就意味着该指令的操作数是一个地址，如果我们在指令后边添加了`_i`后缀，就意味着该指令的操作数是一个立即数。另外需要注意的是，我们实际支持6条地址线，我们只使用指令中的0～5位表示地址操作数；而对于立即数操作数来说，指令中的0～7位都可以用作立即数操作数

> 小贴士：
> 
> 
> 目前halt、store、jmp、je指令不需要后缀，store、jmp、je指令的操作数必定是一个地址（store指令要指明将累加器的数据写到数据RAM的哪个地址处，jmp和je指令要指明需要跳转到指令RAM的哪个地址处的指令执行），halt指令不需要操作数。
> 

引入了立即数的概念之后，我们也要相应的改造一下电路图：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(3)%20914649a7db834c4c8d6881d127711bfc/Untitled%2031.png)

我们在ALU的输入B前边加了一个2-1选择器，该2-1选择器的控制信号ALU_B_SEL由控制单元生成：

- 当执行以_m为后缀的指令时，控制单元生成的ALU_B_SEL为逻辑0，那么采用`数据RAM`的输出作为ALU的输入。
- 当执行以_ｉ为后缀的指令时，控制单元生成的ALU_B_SEL为逻辑1，那么采用立即数作为ALU的输入。
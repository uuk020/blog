# 指令的诞生(1)

RAM输出不同的加数，而ALU的控制信号一直保持不变。这给了我们一个很大的启示：如果针对不同的地址信号，ALU可以有不同的控制信号，那岂不是可以做各种运算

```
74 + 29 - 32 - 20
```

很显然这个表达式中涉及减法，我们不能直接利用前边设计的累加设备来求解它的值，不过如果我们可以针对不同的地址信号，让ALU采用不同的控制信号的话，那么在RST_N信号从逻辑0调整到逻辑1后, `74 + 29 - 32 - 20`的求解过程就可以是这样的：

- 在第0周期中，程序计数器的输出为`0`，也就是地址信号为`0`时，RAM的输出为`74`，相应的ALU的控制信号为`0`（二进制的00），此刻ALU做加法运算 
此时累加器的输出为`0`，ALU做的运算是：`0 + 74`，ALU的输出为`74`
- 在第1周期中，在地址信号为`1`时，RAM的输出为`29`，相应的ALU的控制信号为`0`（二进制的00），此刻ALU做加法运算
    
    此时累加器的输出为`74`，ALU做的运算是：`74 + 29`，ALU的输出为`103`
    
- 在第2周期中，在地址信号为`2`时，RAM的输出为`32`，相应的ALU的控制信号为`1`（二进制的01），此刻ALU做减法运算
    
    此时累加器的输出为`103`，ALU做的运算是：`103 - 32`，ALU的输出为`71`
    
- 在第3周期中，在地址信号为`3`时，RAM的输出为`20`，相应的ALU的控制信号为`1`（二进制的01），此刻ALU做减法运算
    
    此时累加器的输出为`71`，ALU做的运算是：`71 - 20`，ALU的输出为`51`
    

由于振荡器生成的时钟信号频率十分高，我们手速赶不上，不能在地址信号为2时就手动的把ALU的控制信号改为`1`（二进制的01），从而让ALU做减法操作。

不过既然我们可以在不同的地址信号下让RAM输出不同的数，我们也可以再整一个RAM，让这个RAM在不同的地址信号下输出不同的ALU控制信号不就得了

由于ALU的控制信号是用来指导ALU该做啥类型的运算，所以ALU的控制信号又被称作`指令`，而新引入的RAM是用来存储ALU的控制信号的，所以新引入的RAM就可以被称为`指令RAM`

现在电路中存在了两个RAM，为做区别，我们把原先用于存储参与运算的数据的RAM称作`数据RAM`。引入`指令RAM`后的电路图如下所示

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled.png)

可以看到，ALU的控制信号不再恒为0，而是依赖`指令RAM`的输出。这里需要注意注意一下，我们选用的`指令RAM`的容量仍然是`4×8`，也就意味着`指令RAM`的输出包含8个二进制位。而ALU的控制信号只需要2个二进制位。我们给`指令RAM`输出的每一个二进制位编个号

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%201.png)

我们在从`指令RAM`到ALU控制信号的连线上标注了`[1:0]`，这意味着ALU的控制信号其实是`指令RAM`输出的第0位~第1位。如下图所示：

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%202.png)

为求解`74 + 29 - 32 - 20`的结果，我们只需在`指令RAM`和`数据RAM`中分别填入下面的数据（其中`指令RAM`中的数据是二进制形式，`数据RAM中`的数据是十进制形式）

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%203.png)

这样在将复位信号RST_N从逻辑0调整到逻辑1后，我们只需坐等结果了。这里需要提醒大家的是，我们向`指令RAM`中填入的是ALU的控制信号，我们目前设计的ALU只支持4种类型的运算

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%204.png)

### 引入HALT指令

目前选用的`指令RAM`和`数据RAM`的容量都是`4×8`， 也就是只支持对4个数进行运算，如果我们想对5个数进行运算呢？比方说对下边这个表达式进行求值

```
74 + 29 - 32 - 20 + 11
```

- 改进一：将RAM的容量扩大，并更新配套设备（包括地址线条数以及输入设备位数）将`指令RAM`
和`数据RAM`的容量都扩展为`64×8`，这样就可以最多对64个数进行运算了。不过也意味着地址线需要变为6条（2⁶=64）
- 改进二：原先在计算4个数的运算结果时，比较器的一个恒定输入保持为3，意味着在第3周期，也就是程序计数器输出为3的时候就停止执行。现在需要计算5个数的运算结果，所以比较器的一个恒定输入需要保持为4

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%205.png)

| 阶段 | PC输出(地址信号) | 数据RAM输出 | ACC输出 | 指令RAM输出 | ALU输出 | HALT信号 |
| --- | --- | --- | --- | --- | --- | --- |
| 第0周期 | 0 | 74 | 0 | 00(加法) | 74(0+74) | 1 |
| 第1周期 | 1 | 29 | 74 | 00(加法) | 103(74+29) | 1 |
| 第2周期 | 2 | 32 | 103 | 01(减法) | 71(103-32) | 1 |
| 第3周期 | 3 | 20 | 71 | 01(减法) | 51(71-20) | 1 |
| 第4周期 | 4 | 11 | 51 | 00(加法) | 62(51+11) | 0 |

很显然，在第4周期时，电路将停止运行，我们在`8位输出设备`中可以将`74 + 29 - 32 - 20 + 11`的结果读出

那如果我们想要对6个数进行运算呢？简单，我们只需要将比较器的一个恒定输入调整为5就好了。那要对7个数进行运算呢？也简单，将比较器的一个恒定输入调整为6不就好了

可是每次改变参与运算的数字个数时，都得调整一下比较器的恒定输入，也就意味着都得改动一下硬件，这个事情还是比较烦人的。我们重新思考一下在电路中引入比较器的原因，是因为我们需要知道在程序计数器输出哪个地址时将HALT信号设置为逻辑0，从而让电路停止运行

目前我们的`指令RAM`输出8个二进制位代表一条指令，其中编号为0和1的位是用于生成ALU的控制信号的，我们完全可以从其他尚未使用到的二进制位中取一个来代表HALT信号

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%206.png)

接下来可以在电路图中去掉比较器，而让指令中编号为2的二进制位直接作为HALT信号，如下图所示

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%207.png)

那么现在的指令就可以扩充为8个:

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%208.png)

然后在对`74 + 29 - 32 - 20 + 11`表达式进行求值时，最后一条指令就不再填`add`，而是填`add_halt`,ta

| 阶段 | PC输出（地址信号） | 数据RAM输出 | ACC输出 | 指令RAM输出(ALU的控制信号) | ALU输出 | HALT信号 |
| --- | --- | --- | --- | --- | --- | --- |
| 第0周期 | 0 | 74 | 0 | 100（代表加法） | 74（0+74） | 1 |
| 第1周期 | 1 | 29 | 74 | 100（代表加法 | 103（74+29） | 1 |
| 第2周期 | 2 | 32 | 103 | 101（代表减法 | 71（103-32） | 1 |
| 第3周期 | 3 | 20 | 71 | 101（代表减法） | 51（71-20） | 1 |
| 第4周期 | 4 | 11 | 51 | 000（代表加法并停止） | 62（51+11） | 0 |

很显然，在第4周期时，`指令RAM`输出的指令是`000`，指令中编号为2的二进制位是逻辑0，也就意味着HALT信号为逻辑0，这样电路便会停止运行

通过新增指令的方式就可以让电路停下来，而不是每当参与运算的数字个数改变时，就去调整原先电路结构（改变比较器的一个恒定输入）。

不过为了让电路停下来，原先的每个指令都有一个对应的halt版本（add对应add_halt，sub对应sub_halt，and对应and_halt，or对应or_halt），我们目前支持的指令较少，所以引入4条对应的halt指令看起来也没啥问题，如果我们支持的指令更多的话，那么就会有更多条对应的halt指令，这有点而麻烦哦，能不能单独引入一条halt指令来让电路停下来呢？

没问题的，我们可以这样规定指令的二进制形式代表的含义

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%209.png)

我们新增加了一条指令`halt`，当程序计数器输出的地址为5时，`指令RAM`将输出halt指令，halt指令的编号为2的二进制位就代表HALT信号，此时HALT信号将变为逻辑0，整个电路停止运行

在执行halt指令的过程中，我们并不关心ALU的控制信号是什么，所以用`X`来代表指令中编号为0和1的两个二进制位的值（X表示逻辑0或者逻辑1都可以）。另外，在这个过程中地址为5的`数据RAM`中的数据是什么不重要，在执行到halt指令时我们只想让电路停下来，所以我们用`无所谓`来表示`数据RAM`中地址为5处的数据

分析一下在引入halt指令后，在每个时钟周期，电路中各个设备的输出都是什么：

| 阶段 | PC输出（地址信号） | 数据RAM输出 | ACC输出 | 指令RAM输出(ALU的控制信号) | ALU输出 | HALT信号 |
| --- | --- | --- | --- | --- | --- | --- |
| 第0周期 | 0 | 74 | 0 | 100（代表加法） | 74（0+74） | 1 |
| 第1周期 | 1 | 29 | 74 | 100（代表加法） | 103（74+29） | 1 |
| 第2周期 | 2 | 32 | 103 | 101（代表减法） | 71（103-32） | 1 |
| 第3周期 | 3 | 20 | 71 | 101（代表减法） | 51（71-20） | 1 |
| 第4周期 | 4 | 11 | 51 | 100（代表加法） | 62（51+11） | 1 |
| 第5周期 | 5 | 无所谓 | 62 | 0XX（代表停止执行） | 无所谓（62+无所谓） | 0 |

在第5周期中，程序计数器输出的地址为5，`指令RAM`中输出的指令为halt，此时电路停止运行。但是十分不幸的是，在第4周期ALU的输出就代表了`74 + 29 - 32 - 20 + 11`的运算结果，在第5周期的时钟信号上升沿到来后，该结果又被写入到了累加器中。而且在地址为5时，`数据RAM`的输出是一个无所谓的数，这个无所谓的数和累加器的输出作为ALU的两个输入，那么ALU的输出肯定也是一个无所谓的数

因为在第5周期中，`74 + 29 - 32 - 20 + 11`的运算结果已经被写入了累加器，我们直接采用累加器的输出，而不是原先的ALU的输出作为最终输出不就好了

![Untitled](%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%9E%E7%94%9F(1)%2024305890c32f4f97aa9c3dd64055368a/Untitled%2010.png)
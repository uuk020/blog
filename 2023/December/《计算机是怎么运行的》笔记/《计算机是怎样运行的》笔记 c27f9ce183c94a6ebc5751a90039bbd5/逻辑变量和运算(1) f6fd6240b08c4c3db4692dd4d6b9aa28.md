# 逻辑变量和运算(1)

可以将输入信号通过逻辑门后得到输出信号的这个过程当作是一种运算过程，我们可以称之为`逻辑运算`

- 让A作为一个输入信号通过反相器，得到新的逻辑变量Y
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled.png)
    
    `非运算`有一个别名，称为`逻辑求反`，有时候也会简称为`求反`，我们下边用数学的形式描述一下逻辑变量A进行非运算后得到结果Y
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%201.png)
    
- 让A和B分别作为一个输入信号通过与门，得到新的逻辑变量Y
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%202.png)
    
    `与运算`有一个别名，称为`逻辑相乘`（注意与算术相乘做区别）
    
    $Y = A ⋅ B$
    
    或者省略`·`，写成下边这样：
    
    $Y = AB$
    
- 让A和B分别作为一个输入信号通过或门，得到新的逻辑变量Y
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%203.png)
    
    `或运算`有一个别名，称为`逻辑相加`（注意与算术相加做区别）
    
    $Y = A + B$
    
- 让A和B分别作为一个输入信号通过异或门，得到新的逻辑变量Y
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%204.png)
    
    用数学的形式描述一下逻辑变量A、B进行或运算后得到结果Y
    
    $Y=A⊕B$
    

在逻辑变量A、B的值确定之后，Y的值也就确定了，我们就把A、B称为输入变量，或者叫自变量，Y称为输出变量，或者叫因变量，Y和A、B之间的映射关系也被称为函数
变量都是逻辑变量，输出变量和输入变量之间的映射关系也被称作逻辑函数。像Y = A、Y = AB 这样的表征逻辑函数的式子也被称作`逻辑函数式`

`逻辑函数式`只是表示逻辑函数的一种方式，我们还可以用其他形式来描述输入变量和输出变量之间的逻辑函数

- 采用真值表的方式描述逻辑函数
    
    真值表是一种最原始的逻辑函数描述方式，我们只要将输入变量所有可能的取值都列出来，然后找出对应的输出变量即可
    
    | A | B | C | Y |
    | --- | --- | --- | --- |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 1 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 0 | 0 |
    | 1 | 0 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 1 | 1 |
- 采用逻辑图的方式描述逻辑函数
    
    说对于下边这个逻辑函数式表征的逻辑函数来说：
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%205.png)
    
    对A求反后再与B进行与运算，那么就在A后边先放置一个反相器，再将反相器的输出与B作为一个与门的输入
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%206.png)
    
    对A和C进行与运算，如下图所示
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%207.png)
    
    上边两个步骤的输出再做或运算，那么就将上边两个步骤的输出作为或门的输入，这个或门的输出就作为逻辑函数最后的输出Y，如下图所示
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%208.png)
    

对于二进制来说，因为只有2个符号来代表数值，加法表:

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%209.png)

不过对于这个二进制加法表来说，有一个地方需要注意一下，就是在计算`1+1`的时候，需要2个二进制位来表示结果，我们把结果中左边的那个位称之为`进位`，右边的那个位称之为`加法位`

我们也可以使用2个二进制位来表示结果，只不过进位为0罢了

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2010.png)

假设`A`、`B`分别代表仅有1位的二进制数，那么`A+B`可能的情况就有4种

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2011.png)

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2012.png)

- `A`和`B`作为与门的输入，那么该与门的输出就代表进位的值。
- `A`和`B`作为异或门的输入，那么该异或门的输出就代表加法位的值

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2013.png)

我们决定把这个电路装到一个盒子里，只露出输入和输出的连接线

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2014.png)

我们把方框里边的那个电路称之为`半加器`（Half Adder）

加数必须是由单个二进制位组成的（加数必须是0或者1）。而我们平时所做的加法运算中，各个加数都可能包含多个二进制位

```markdown
11010111 + 10010001
```

每个加数都包含8个二进制位。对于这种包含多个二进制位的加数相加的场景，我们可以将两个加数权重相同的位对齐，从权重最低的位开始相加，逢2进1，直到所有的位相加完毕

- 先计算权重最低的位之和
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2015.png)
    
    我们规定最右边的那个二进制位为第0位，之后沿着从右向左的方向依次是第1位、第2位、...。两个加数中权重最低的位自然是第0位，两个加数的第0位的值分别是`1`和`1`，我们计算`1 + 1`的值，得到的加法位就是`0`，进位为`1`
    
- 接着计算两个二进制加数的第1位的和，就像这样
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2016.png)
    
    两个加数的第1位的值分别是`1`和`0`，当然还需要考虑上一步骤中的进位，也就是说我们需要计算`1 + 0 + 1`的值，得到的加法位就是`0`，进位为`1`
    
- 依次类推，直到所有的位相加完毕，得到的结果就是这样
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2017.png)
    
    在计算两个加数权重最低的位，也就是从右往左数的第1列二进制位相加时，我们可以直接使用前边已经唠叨过的`半加器`来获得对应的加法位输出和进位输出，可是对于其他位置的位相加时，不能单纯的使用`半加器`了，这是因为要考虑上一列二进制位相加的进位，其实本质上我们需要一个可以计算3个二进制位相加的机器，也就是说我们期望有下边电路结构(图中的`Cin`表示上一列二进制位相加的进位)
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2018.png)
    
    `A`、`B`、`Cin`这三个输入都可能取0或者1，所以总共的输入情况共有8种，我们把每一种输入情况下产生的进位输出`Cout`和加法位输出`S`列一个表格:
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2019.png)
    
- 先做一个只有在`Cin=0, A=1, B=1`时输出才为1的设备，就像这样
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2020.png)
    
- 再做一个只有在`Cin=1, A=0, B=1`时输出才为1的设备，就像这样
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2021.png)
    
- 再做一个只有在`Cin=1, A=1, B=0`时输出才为1的设备，就像这样
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2022.png)
    
- 再做一个只有在`Cin=1, A=1, B=1`时输出才为1的设备，就像这样
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2023.png)
    
- 上述四个设备产生的输出作为一个四输入或门的输入:
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2024.png)
    

实现生成`S`信号的电路还可以使用我们之前设计的`半加器`来实现这个电路黑盒。三个单独的二进制位相加的计算过程肯定是先计算其中两个二进制位相加的和之后再和第三个二进制位相加

1. 做第一次加法：先对A、B这两个二进制位做加法运算，我们把这次加法得到加法位和进位分别称作`S₁`和`CO₁`

    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2025.png)
    
2. 做第二次加法：把上一步算出来的加法位`S₁`和进位输入`Cin`相加，我们把这次加法得到的加法位和进位分别称作`S₂`和`CO₂`，很显然`S₂`就是这三个二进制位加法运算的最终加法位
    
    ![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2026.png)
    
3. 接下来需要将`CO₁`和`CO₂`相加一下，不过`CO₁`和`CO₂`肯定不会同时为1
    1. 如果`CO₁`为`1`的话，说明`A`和`B`的值均为`1`，那么它们相加产生的加法位`S₁`肯定为`0`，那么不管进位输入`Cin`是什么，`Cin`与`0`相加产生的加法位`S₂`的值就是`Cin`自己，进位`CO₂`肯定是`0`。
    2. 如果`CO₂`为`1`的话，说明`S₁`和进位输入`Cin`均为`1`，如果此时`CO₁`的值也为`1`的话，那就意味着`A`和`B`相加的结果是二进制数`11`，而我们知道这是不可能的。
    - 如果`CO₁`和`CO₂`均为0，那么它们的和也为0。
    - 如果`CO₁`和`CO₂`中有一个为1，那么它们的和就是1.

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2027.png)

我们把方框里边的那个电路称之为`全加器`（Full Adder），以后我们就使用上图中的电路符号来代表`全加器`，而不用关心内部是如何实现的了

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2028.png)

```markdown
		11010111
+   10010001
```

这个加法运算的每一个二进制加数都包含8个位，如果我们想用`全加器`来计算它们的和，那就需要八个步骤

1. 先分别取出两个二进制加数第0位作为全加器的输入`A`和输入`B`，此时的进位输入`Cin`为`0`，得到加法位输出`S₀`和进位输出`C₀`
2. 再分别取出两个二进制加数第1位作为全加器的输入`A`和输入`B`，将上一步骤的进位输出`C₀`作为本次运算的进位输入`Cin`，得到加法位输出`S₁`和进位输出`C₁`
3. 类似的，两个二进制数的第2位相加，得到加法位输出`S₂`和进位输出`C₂`。
4. 类似的，两个二进制数的第3位相加，得到加法位输出`S₃`和进位输出`C₃`。
5. 类似的，两个二进制数的第4位相加，得到加法位输出`S₄`和进位输出`C₄`。
6. 类似的，两个二进制数的第5位相加，得到加法位输出`S₅`和进位输出`C₅`。
7. 类似的，两个二进制数的第6位相加，得到加法位输出`S₆`和进位输出`C₆`。
8. 类似的，两个二进制数的第7位相加，得到加法位输出`S₇`和进位输出`C₇`。

然后我们只需要将各个步骤的加法位输出按照从大到小的顺序排列，并将第8步的进位输出`C₇`作为最高位就可以得到最终的加和结果

```markdown
C₇S₇S₆S₅S₄S₃S₂S₁S₀
```

总结一下上边除步骤1以外的其他步骤都有一个共同的操作：将上一步骤的加法产生的进位输出作为本次加法的进位输入

假设我们现在要计算两个8位二进制数的和，这两个8位二进制数分别是`A₇A₆A₅A₄A₃A₂A₁A₀`、`B₇B₆B₅B₄B₃B₂B₁B₀`，其中`An`和`Bn`（n是`0~7`之间的整数）分别代表一个二进制位。我们很容易可以画出下边的电路图

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2029.png)

按照从右往左的顺序看这个电路图，这是一个解决8位二进制数加法的电路图。初始的时候进位输入为0，然后每一位相加的进位输出当作高一位相加的进位输入，`C₇S₇S₆S₅S₄S₃S₂S₁S₀`就是最后的加法结果

我们简化一下上边的图，下图中`Cout`代表最高位全加器的进位输出`C₇`，初始的进位输入`Cin`恒为0

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2030.png)

但是这个图还是太复杂了，继续简化一下。现在我们假设`A`、`B`是两个8位二进制数，分别代表`A₇A₆A₅A₄A₃A₂A₁A₀`、`B₇B₆B₅B₄B₃B₂B₁B₀`，`S`代表最终的输出结果`S₇S₆S₅S₄S₃S₂S₁S₀`，那么简化后的电路图就长这样

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2031.png)

为了通用起见，我们也可以设计处理`n`位（n是大于0的整数）二进制数加法的加法器（只需要串联n个`全加器`就好了），一个更通用些的`n位加法器`的示意图就如下所示

![Untitled](%E9%80%BB%E8%BE%91%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97(1)%20f6fd6240b08c4c3db4692dd4d6b9aa28/Untitled%2032.png)

在现实世界中，我们可以使用任意个数的二进制位来表示数字，不过如果将二进制位映射到信号线上，由于信号线的个数有限，所以我们只能使用固定个数的信号线来表示数字，这也就意味着我们只能使用固定个数的二进制位来表示数字

为方便起见，我们在使用固定个数的二进制位表示的数字时，将最左边的那个二进制位，也就是权重最高的那个二进制位称为`最高有效位`，把最右边的那个二进制位，也就是权重最低的那个二进制位称为`最低有效位`

如果我们规定最多使用8个二进制位表示数字，那么两个8位二进制数相加之后产生的结果也需要由8个二进制位来表示。

视角回到上边介绍的`8位加法器`，两个8位二进制数A、B分别代表`A₇A₆A₅A₄A₃A₂A₁A₀`、`B₇B₆B₅B₄B₃B₂B₁B₀`，它们相加的结果就是：`C₇S₇S₆S₅S₄S₃S₂S₁S₀`，如果我们现在规定只能使用8个二进制位来表示数字，那只能把两个加数的最高有效位相加时的进位输出`C₇`给舍弃掉，单纯使用`S₇S₆S₅S₄S₃S₂S₁S₀`来表示加和结果。

- 当进位输出`C₇`的值为`0`时，舍弃就舍弃了，并不会改变结果的大小。
- 当进位输出`C₇`的值为`1`时，舍弃时就相当于将最终的结果减去了`28`，我们就称此时的加法运算发生了`溢出`

现在如果我们规定使用8个二进制位表示数字，能表示的二进制数范围就是：`00000000₂~11111111₂`，也就是：`0~281`，如果两个8位二进制数相加的结果大于`281`，那么最终的结果是无法用8个二进制位来表示的，此时就会发生溢出现象。比方说二进制数`11010111₂`（十进制形式：215）和`10010001₂`

得到的结果是`101101000`，不过很无奈，现在只能使用8个二进制位表示数字，那结果自然就成了`01101000`（十进制形式：104），此时便发生了溢出
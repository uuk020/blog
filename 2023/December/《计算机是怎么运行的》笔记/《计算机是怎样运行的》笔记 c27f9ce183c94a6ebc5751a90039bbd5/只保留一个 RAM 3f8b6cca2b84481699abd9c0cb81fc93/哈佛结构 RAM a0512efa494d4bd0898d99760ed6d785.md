# 哈佛结构 RAM

现在省略电路中的时钟信号线和复位信号线的连接，再来重新梳理一下电路中各个部件之间的数据流动

1. 有一个`程序计数器`，它的输出表示我们当前正在执行指令的地址：
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled.png)
    
2. `程序计数器`的输出连接到`指令RAM`，指令RAM的输出代表一条指令：
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%201.png)
    
    目前我们设计的一条指令包含16个二进制位，其中8～15位规划作为操作码，实际使用了8～11位；0～7位规划作为操作数，操作数分为两类：
    
    - 使用立即数作为操作数，目前的设计中指令中的0～7位代表一个立即数。比方说add_i指令的操作数就是立即数
    - 使用 RAM 地址作为操作数，目前的设计中指令中的0～5位代表一个地址。比方说add_m、jmp、store指令的操作数就是RAM地址
    
    我们可以把操作码称作`opcode`，把代表立即数的操作数称作`operand_imm`，把代表地址的操作数称作`operand_addr`，那么一条指令就可以被画出三个分支
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%202.png)
    
3. 先看`operand_addr`分支，在执行需要访问RAM的指令中，需要先从`数据RAM`中把指令中给定地址处的数据读出，那么`operand_addr`其实就作为一个`数据RAM`的地址输入，如下图所示
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%203.png)
    
    `数据RAM`的输出有两个用途：
    
    - 是作为 ALU 的输入 B 参与运算，比方说 add_m 指令就是要从 RAM 中读出指定地址的数据与累加器中的数据做加法
    - 是作为跳转指令的目的地址，比方说 jmp、je 指令都需要指定下一条指令的地址
4. 以立即数作为操作数的算术/逻辑运算指令（比方说 add_i ）需要将指令中的立即数（也就是operand_imm）与累加器中的数据进行运算，以RAM地址作为操作数的算术/逻辑运算指令（比方说add_m）需要从`数据RAM`中读出给定地址的数据（也就是 alu_b_value ）然后与累加器中的数据进行运算。operand_imm 和 alu_b_value 都会被作为ALU的输入B的输入，所以它们需要先通过一个`2-1选择器`然后在与ALU的输入 B 连起来，如下图所示：
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%204.png)
    
5. ALU的输入A来自累加器（简称ACC），在执行完算术/逻辑运算指令后，运算结果应该还写回到累加器中，效果如下图所示
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%205.png)
    
    这里我们把原先ALU的控制信号S₁、S₀统称为`ALU_OP`
    
6. load 类型指令用于将某个数加载到累加器中（ load_i 加载的是立即数，load_m 加载的是RAM中的数），被加载的数据被放到了 ALU 的输入 B 处。此时我们将 ALU＿OP 设置为加法，然后让ALU 的输入 A 为 0即可达到让累加器的输入为 ALU 的输入 B 的效果，这样我们就得在 ALU 的输入 A 前边加一个`2-1选择器`，如下图所示
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%206.png)
    
7. 为支持 store 指令，即将累加器中存储的数据写到`数据RAM`中，累加器的输出应该作为`数据RAM`的数据输入，如下图所示：
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%207.png)
    
8. 正常情况下，在执行完一条指令后，应该执行地址比当前指令地址大1的新指令，如下图所示：
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%208.png)
    
    但是在执行 jmp、je 等跳转指令时，程序计数器的输入应该为 jmp_addr ，此时我们需要引入一个`2-1选择器`，如下图所示：
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%209.png)
    
9. 各种`2-1选择器`的控制信号、累加器和数据 RAM 的 WE 信号以及 ALU 的控制信号都是根据当前正在执行的指令生成的，指令的 opcode 通过控制单元，由控制单元来统一生成这些信号，如下图所示:
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%2010.png)
    
10. 对于条件跳转指令 je 来说，只有在执行上一条指令后 ALU 的输出为0时，je指令才真正执行跳转。这就导致需要ZF寄存器来存储一下ALU的结果是否为0，并且将ZF寄存器的输出作为`控制单元`的输入来生成控制信号（ZF寄存器的输出只影响 PC_SEL 信号），如下图所示：
    
    ![Untitled](%E5%93%88%E4%BD%9B%E7%BB%93%E6%9E%84%20RAM%20a0512efa494d4bd0898d99760ed6d785/Untitled%2011.png)
    
    > halt 指令用来让电路停止执行，我们是采用让各个寄存器以及 RAM 接收不到 CLK 信号的方式来实现 halt 指令的，由于我们省略了 CLK 信号，所以在上图中也未画出 halt 指令的实现
    >
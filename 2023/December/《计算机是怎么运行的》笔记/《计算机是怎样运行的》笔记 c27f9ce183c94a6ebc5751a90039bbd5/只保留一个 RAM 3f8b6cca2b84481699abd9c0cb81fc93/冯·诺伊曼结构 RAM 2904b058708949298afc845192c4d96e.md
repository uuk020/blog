# 冯·诺伊曼结构 RAM

本质上`指令`和`数据`都是一堆二进制位，只是人为的将其区分为指令和数据, 那么可以用一个 RAM, 这个 RAM 既存储指令, 也存储数据.  这种把指令和数据都存储到同一个存储设备中的计算机结构也被称作`冯·诺伊曼结构`

下边这个电路图：

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled.png)

每当时钟信号上升沿到来后，寄存器的输出b代表的数据将被更新为输入a代表的数据，而且经过组合逻辑所需的一段传输延迟时间后，组合逻辑的输出c稳定后将保持不变

也就是说，在一个时钟周期内，各个信号线代表的数据最终会稳定在某个值并保持不变，在下个时钟信号上升沿到来后才会被更新为别的值

这样的话，如果我们仅使用1个RAM来既存储指令，又存储数据的话，那么在某个时钟周期内，该RAM的地址信号到底代表指令的地址，还是该代表数据的地址呢？以及该RAM的输出到底代表指令，还是代表数据呢？如下图所示：

![Snipaste_2023-02-14_00-15-18.png](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Snipaste_2023-02-14_00-15-18.png)

在一个时钟周期内，地址信号线要么表示指令对应的地址，要么表示数据对应的地址

**取指和执行状态**

既然一个时钟周期搞不定，那我们就整两个时钟周期，一个时钟周期用于读取指令，另一个时钟周期用于读取数据。这两个时钟周期也可以被称作两个阶段：

- 取指阶段。在这个阶段，RAM的地址信号代表指令的地址，RAM的输出代表指令
- 执行阶段。在这个阶段，RAM的地址信号代表数据的地址，RAM的输出代表数据。也是在这个阶段，真正的执行指令

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%201.png)

如上图所示，第0周期是取指阶段，第1周期是执行阶段，第2周期又是取指阶段，第3周期又成了执行阶段，就这样一直取指、执行、取指、执行下去

因为现在电路只能处在取指阶段或者执行阶段，我们就说电路可以处在两个状态：

- 状态一：取指状态。我们把处在取指阶段的电路称为处在取指状态
- 状态二：执行状态。我们把处在执行阶段的电路称为处在执行状态

接下来可以给电路的不同状态编一个号：

- 取指状态编号为0
- 执行状态编号为1

把电路当前处在的状态称为Snow，把电路的下一个状态称为Snext。那么：

- 如果当前电路处于取指状态，那么它的下一个状态就是执行状态，也就是当Snow = 0时，Snext
=1
- 如果当前电路处于执行状态，那么它的下一个状态就是取指状态，也就是当Snow=1时，Snext
=0

如果当前电路处于执行状态，那么它的下一个状态就是取指状态，也就是当Snow=1时，Snext=0

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%202.png)

这显然是一个反相器的真值表，不过电路的状态只能在时钟信号上升沿到来后才能更新，那我们可以引入一个称为`状态寄存器`的寄存器来保存电路当前所处于的状态，如下图所示

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%203.png)

如图所示，输出信号STATE表示着电路当前处在的状态。当STATE=0时，表示电路当前处于取指状态，当STATE=1时，表示电路当前处于执行状态。我们可以把上边的这个电路装在黑盒子里，只露出CLK和RST_N输入信号以及STATE输出信号, 然后将这个设备称为`状态生成器`，如下图所示：

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%204.png)

这个`状态生成器`是一个可以生成状态的机器，所以也可以被称为`状态机`，因为我们目前只能生成`0`（取指状态）和`1`（执行状态）两种状态，所以这个设备也可以被称为`有限状态机`

那么，在RST_N=0时，输出信号STATE始终为逻辑0，当把RST_N从逻辑0调整为逻辑1后，每当有时钟信号上升沿到来后，输出信号STATE都会取反。

也就意味着每次时钟信号上升沿到来后，电路的状态会在取指状态和执行状态之间切换。我们把在RST_N=1时的状态变换过程用下图表示一下：

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%205.png)

**电路改进**

之前都是使用1个时钟周期来执行一条指令的，在引入了`取指阶段`和`执行阶段`后，我们需要在`取指阶段`将指令从`RAM`中取出，然后在`执行阶段`真正的执行指令（所谓“真正的执行”就是指根据指令作为输入，通过控制单元产生各种控制信号，来指导各个器件完成不同的功能），也就意味着我们需要2个时钟周期去执行一条指令。

事情变得稍微复杂了一些，我们再从头看一下数据在各个部件之间是如何流动的：

1. 有一个`程序计数器`，它的输出表示我们当前正在执行指令的地址: 

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%206.png)

1. `程序计数器`的输出到`RAM`，在`取指阶段`，RAM的输出代表一条指令:

![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%207.png)

1. 在`取指阶段`从RAM中读出的指令实际上是在下一个时钟周期，也就是`执行阶段`才真正的被执行，所以我们需要引入一个寄存器来保存在`取指阶段`从RAM中读出的指令，如下图所示
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%208.png)
    
    把保存指令的寄存器称作`指令寄存器`（Instruction Register，简称IR）
    
2. 现在是2个时钟周期执行一条指令，在`执行阶段`的时钟上升沿到来后才会真正的更新`IR寄存器`，而在`取指阶段`的时钟上升沿到达后并不需要更新`IR寄存器`，我们有必要使用带写使能信号的寄存器来制作`IR寄存器`
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%209.png)
    
    - 在`取指阶段`，STATE=0，令IR_WE=1, 那么在`执行阶段`的时钟信号上升沿到达后，IR寄存器中的指令被更新，在执行阶段执行该指令,
    - 在`执行阶段`，STATE=1，令IR_WE=0，那么在`取指阶段`的时钟信号上升沿到达后，IR寄存器中的指令不被更新
    1. 因为2个时钟周期执行一条指令，我们需要在`取指阶段`的时钟上升沿到达后更新程序计数器，而在`执行阶段`的时钟信号上升沿到达后不更新程序计数器，所以我们有必要使用带写使能信号的寄存器来制作`程序计数器`：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2010.png)
        
        - 在`取指阶段`，STATE=0，令PC_WE=0，那么在`执行阶段`的时钟信号上升沿到达后，PC寄存器中的指令地址不被更新
        - 在`执行阶段`，STATE=1，令PC_WE=1，那么在`取指阶段`的时钟信号上升沿到达后，PC寄存器中的指令地址被更新
    2. 在执行阶段，IR寄存器的输出代表着当前需要执行的指令，目前一条指令共占用16个二进制位，其中：
        - 8～15位被规划作为操作码，实际使用了8～11位，操作码用opcode表示。
        - 0～7位代表一个立即数，立即数用operand_imm表示
        - 0～5位代表一个地址，地址用operand_addr表示
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2011.png)
        
    3. 在执行阶段，执行需要访问 RAM 的指令时，需要 operand_addr 作为RAM的地址输入，这样的话，RAM 就有了2个地址输入（程序计数器的输出和 operand_addr ），引入一个`2-1选择器`即可解决该问题
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2012.png)
        
        很显然：
        
        - 在`取指阶段`，也就是 STATE =0时，令 RAM_ADDR_SEL =0，表明要从 RAM 中读取指令
        - 在`执行阶段`，也就是 STATE =1时，令 RAM_ADDR_SEL=1，表明要从 RAM 中读取数据
        
        如上图所示，当 RAM_ADDR_SEL =1时，从RAM中读取的数据共包含16个二进制位，共有两种用途：
        
        - 一是作为 ALU 的输入 B 参与运算，比方说 add_m 指令就是要从 RAM 中读出指定地址的数据与累加器中的数据做加法，图中用 alu_b_value 表示
        - 二是作为跳转指令的目的地址，比方说 jmp、je 指令都需要指定下一条指令的地址，图中用 jmp_addr 表示（由于目前的 RAM 总共有6根地址线，最多支持64个地址，所以我们只选取第0～5位作为跳转地址）
    4. 以立即数作为操作数的算术/逻辑运算指令（比方说add_i）需要将指令中的立即数（也就是operand_imm）与累加器中的数据进行运算，以RAM地址作为操作数的算术/逻辑运算指令（比方说add_m）需要从`数据RAM`中读出给定地址的数据（也就是alu_b_value）然后与累加器中的数据进行运算。operand_imm和alu_b_value都会被作为ALU的输入B的输入，所以它们需要先通过一个`2-1选择器`然后在与ALU的输入B连起来。不过目前只使用1个64×16的RAM来既存储指令也存储数据，从RAM中读取的数据包含16个二进制位，而operand_imm只包含7个二进制位，我们需要先将operand_imm扩展为16个二进制位。我们这里支持有符号数的运算，所以采用符号扩展，如下图所示：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2013.png)
        
        > 此时ALU的每个输入的位数都是16，也就是说ALU负责对两个16位二进制数进行运算
        > 
    5. ALU的输入A来自累加器（简称ACC），在执行完算术/逻辑运算指令后，运算结果应该还写回到累加器中，效果如下图所示：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2014.png)
        
    6. 为支持 load 指令，需要在ALU的输入A前边加一个`2-1选择器`，如下图所示：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2015.png)
        
    7. 为支持 store 指令，即将累加器中存储的数据写到`数据RAM`中，累加器的输出应该作为`数据RAM`的数据输入，如下图所示：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2016.png)
        
    8. 正常情况下，在执行完一条指令后，应该执行地址比当前指令地址大1的新指令，如下图所示：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2017.png)
        
        但是在执行 jmp、je 等跳转指令时，程序计数器的输入应该为jmp_addr，此时我们需要引入一个`2-1选择器`，如下图所示：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2018.png)
        
    9. 在`执行阶段`，ALU的输出是否为0的结果应该作为ZF寄存器的输入，以供之后执行je指令使用。不过在`取指阶段`，ALU的输出是否为0的结果不应写入ZF寄存器，这样我们就得使用带使能信号的寄存器作为ZF寄存器，如下图所示：
        
        ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2019.png)
        
    
    **控制单元的制作**
    
    引入的3个新设备的控制信号：RAM_ADDR_SEL、PC_WE、IR_WE应如何生成。前边讨论了RAM_ADDR_SEL、PC_WE、IR_WE信号和STATE信号之间的关系，如下表所示
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2020.png)
    
    以STATE为输入信号，以RAM_ADDR_SEL、PC_WE、IR_WE为输出信号的组合电路：
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2021.png)
    
    也可以把上图中通过STATE信号生成这些控制信号的电路称作一个控制单元，不过之前的电路里已经有过一个控制单元了，就把上图的电路称作`2号控制单元`
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2022.png)
    
    为和刚刚制作的`2号控制单元`做区分，我们将之前在一个时钟周期中执行一条指令时用到的控制单元称为`1号控制单元`，`1号控制单元`长这样（图中未画出HALT信号）：
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2023.png)
    
    当累加器、RAM、ZF寄存器这些设备的WE信号为逻辑1时，在下一个时钟信号上升沿到来后便会更新它们所存储的值。在`取指阶段`并不真正执行指令，所以需要将这些设备的WE信号全都设置为逻辑0，在`执行阶段`这些设备的WE信号是由`1号控制单元`产生的
    
    - 在`取指阶段`，也就是STATE=0时，RAM_WE、ACC_WE、ZF_WE保持为逻辑0不变。
    - 在`执行阶段`，也就是STATE=1时，RAM_WE、ACC_WE与`1号控制单元`输出的RAM_WE、ACC_WE一致，ZF_WE信号为逻辑1
    
    所以我们可以用下图所示的方式将`1号控制单元`和`2号控制单元`连接起来
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2024.png)
    
    其中的`STATE`信号是通过`状态生成器`生成的，我们也把`状态生成器`也画出来：
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2025.png)
    
    老规矩，上边的图太复杂了，我们把`1号控制单元`、`2号控制单元`和`状态生成器`合并为一个大的`控制单元`，那么这个`控制单元`的示意图就如下所示：
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2026.png)
    
    把这个复杂的`控制单元`放到电路中吧：
    
    ![Untitled](%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84%20RAM%202904b058708949298afc845192c4d96e/Untitled%2027.png)
# Go 指针

指针也就是内存地址，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同

在计算机中, 所有的数据都是存放在存储器中的, 不同的数据类型占有的内存空间的大小各不相同。内存是以字节为单位的连续编址空间, 每一个字节单元对应着一个唯一的编号, 这个编号被称为内存单元的地址。

内存为变量分配存储空间的首个字节单元的地址, 称之为该变量的地址。地址用来标识每一个存储单元, 方便用户对存储单元中的数据进行正确的访问。

Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算。通过给予程序员基本内存布局，Go 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这些对构建运行良好的系统是非常重要的

Go 语言的取地址符是 `&`，放到一个变量前使用就会返回相应变量的内存地址。

```go
var i1 = 5
fmt.Printf("i1 的值: %d, 内存地址为 %p\n", i1, &i1) // i1 的值: 5, 内存地址为 0xc00000a098 不同环境下内存地址是不用的

```

声明一个指针变量, 通过 `*` 加类型来声明

```go
var intP *int // 声明一个指针变量
inP = &i1 // 将i1的内存地址赋予指针变量

```

一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。

符号 * 可以放在一个指针前，如 *intP，那么它将得到这个指针指向地址上所存储的值；这被称为反引用（或者内容或者间接引用）操作符；另一种说法是指针转移

```go
var i = 5
var intP *int
intP = &i
fmt.Printf("i的内存地址: %p\n", &i) // 0xc00000a0d0
fmt.Printf("intP的内存地址: %p\n", intP) // 0xc00000a0d0
*intP = 6 // 反引用
fmt.Println(i) // 6
fmt.Println(*intP) // 6
fmt.Printf("改变后 i 的内存地址: %p\n", &i) // 0xc00000a0d0
fmt.Printf("改变后 intP的内存地址: %p\n", intP) // 0xc00000a0d0

```

你不能得到一个文字或常量的地址; 所谓的指针算法，如：pointer+2，移动指针指向字符串的字节数或数组的某个位置）是不被允许的。Go 语言中的指针保证了内存安全，更像是 Java、C# 和 [VB.NET](http://vb.net/) 中的引用。因此 c = *p++ 在 Go 语言的代码中是不合法的。

指针的一个高级应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。指针传递是很廉价的，只占用 4 个或 8 个字节。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。被指向的变量也保存在内存中，直到没有任何指针指向它们，所以从它们被创建开始就具有相互独立的生命周期。

另一方面（虽然不太可能），由于一个指针导致的间接引用（一个进程执行了另一个地址），指针的过度频繁使用也会导致性能下降。
指针也可以指向另一个指针，并且可以进行任意深度的嵌套，导致你可以有多级的间接引用，但在大多数情况这会使你的代码结构不清晰。

参考资料

- [800 字彻底理解 Go 指针](https://learnku.com/go/t/35168)
- [C语言指针怎么理解](https://www.zhihu.com/question/24466000)
- [C-指针](https://www.jianshu.com/p/63f3bfb58687)
- [C语言中&取地址取到的地址是真实内存地址吗?](https://www.zhihu.com/question/379177766)